<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jesonwoo&#39;s Blog</title>
  
  <subtitle>珍爱家人，珍惜财富，保持进步</subtitle>
  <link href="https://jesonwoo.github.io/atom.xml" rel="self"/>
  
  <link href="https://jesonwoo.github.io/"/>
  <updated>2022-03-14T09:22:01.271Z</updated>
  <id>https://jesonwoo.github.io/</id>
  
  <author>
    <name>Jesonwoo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序编译(1)-目标文件的编译步骤</title>
    <link href="https://jesonwoo.github.io/2022/03/04/%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91-1-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E8%AF%91%E6%AD%A5%E9%AA%A4/"/>
    <id>https://jesonwoo.github.io/2022/03/04/%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91-1-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E8%AF%91%E6%AD%A5%E9%AA%A4/</id>
    <published>2022-03-04T07:33:12.000Z</published>
    <updated>2022-03-14T09:22:01.271Z</updated>
    
    <content type="html"><![CDATA[<p>因为工作需要，最近需要搭建跨平台工程。其中涉及到了依赖库交叉编译等工作。<br>因此趁这个机会写一个关于c/c++编译器的工作机制的小系列，</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>广义上的”编译”指的是由代码、模块、资源等构建成机器码的过程。狭义上的”编译”则指的是源代码到汇编代码的过程。而标题中的”编译”则是广义上的。那为什么需要了解其中的原理呢？</p><p><strong>了解原理可以让我们解决编译过程中遇到的任何问题都可以快速定位和解决</strong></p><h2 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h2><blockquote><p> c/c++广义上的编译都需要经过以下这4步：预处理（Prepressing）-&gt;编译（Compilation）-&gt;汇编（Assembly）-&gt;链接（Linking）</p></blockquote><p>示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_VAR 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> kStaticInitVar = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> kStaticUnnitVar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s-var:%d\n&quot;</span>,__FUNCTION__, var);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> localStaticInitVar = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> localStaticUnintVar;</span><br><span class="line"></span><br><span class="line">    func(kStaticInitVar + localStaticInitVar + DEF_VAR);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个编译过程可以通过<code>gcc -v test.c -o test.out</code>查看，结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/lib/gcc/arm-linux-gnueabihf/10/lto-wrapper</span><br><span class="line">Target: arm-linux-gnueabihf</span><br><span class="line">Configured with: ../src/configure -v --with-pkgversion=&#x27;Raspbian 10.2.1-6+rpi1&#x27; --with-bugurl=file:///usr/share/doc/gcc-10/README.Bugs --enable-languages=c,ada,c++,go,d,fortran,objc,obj-c++,m2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-10 --program-prefix=arm-linux-gnueabihf- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-libitm --disable-libquadmath --disable-libquadmath-support --enable-plugin --with-system-zlib --enable-libphobos-checking=release --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-sjlj-exceptions --with-arch=armv6 --with-fpu=vfp --with-float=hard --disable-werror --enable-checking=release --build=arm-linux-gnueabihf --host=arm-linux-gnueabihf --target=arm-linux-gnueabihf</span><br><span class="line">Thread model: posix</span><br><span class="line">Supported LTO compression algorithms: zlib zstd</span><br><span class="line">gcc version 10.2.1 20210110 (Raspbian 10.2.1-6+rpi1)</span><br><span class="line">COLLECT_GCC_OPTIONS=&#x27;-v&#x27; &#x27;-o&#x27; &#x27;test.out&#x27;  &#x27;-mfloat-abi=hard&#x27; &#x27;-mfpu=vfp&#x27; &#x27;-mtls-dialect=gnu&#x27; &#x27;-marm&#x27; &#x27;-march=armv6+fp&#x27;</span><br><span class="line"> /usr/lib/gcc/arm-linux-gnueabihf/10/cc1 -quiet -v -imultilib . -imultiarch arm-linux-gnueabihf test.c -quiet -dumpbase test.c -mfloat-abi=hard -mfpu=vfp -mtls-dialect=gnu -marm -march=armv6+fp -auxbase test -version -o /tmp/ccr8xe6E.s</span><br><span class="line">GNU C17 (Raspbian 10.2.1-6+rpi1) version 10.2.1 20210110 (arm-linux-gnueabihf)</span><br><span class="line">        compiled by GNU C version 10.2.1 20210110, GMP version 6.2.1, MPFR version 4.1.0, MPC version 1.2.0, isl version isl-0.23-GMP</span><br><span class="line"></span><br><span class="line">GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072</span><br><span class="line">ignoring nonexistent directory &quot;/usr/local/include/arm-linux-gnueabihf&quot;</span><br><span class="line">ignoring nonexistent directory &quot;/usr/lib/gcc/arm-linux-gnueabihf/10/include-fixed&quot;</span><br><span class="line">ignoring nonexistent directory &quot;/usr/lib/gcc/arm-linux-gnueabihf/10/../../../../arm-linux-gnueabihf/include&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">include <span class="string">&quot;...&quot;</span> search starts here:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;...&gt; search starts here:</span></span><br><span class="line"> /usr/lib/gcc/arm-linux-gnueabihf/10/include</span><br><span class="line"> /usr/local/include</span><br><span class="line"> /usr/include/arm-linux-gnueabihf</span><br><span class="line"> /usr/include</span><br><span class="line">End of search list.</span><br><span class="line">GNU C17 (Raspbian 10.2.1-6+rpi1) version 10.2.1 20210110 (arm-linux-gnueabihf)</span><br><span class="line">        compiled by GNU C version 10.2.1 20210110, GMP version 6.2.1, MPFR version 4.1.0, MPC version 1.2.0, isl version isl-0.23-GMP</span><br><span class="line"></span><br><span class="line">GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072</span><br><span class="line">Compiler executable checksum: b0c2f0ffcfbe7fc710aaf45c31c63944</span><br><span class="line">COLLECT_GCC_OPTIONS=&#x27;-v&#x27; &#x27;-o&#x27; &#x27;test.out&#x27;  &#x27;-mfloat-abi=hard&#x27; &#x27;-mfpu=vfp&#x27; &#x27;-mtls-dialect=gnu&#x27; &#x27;-marm&#x27; &#x27;-march=armv6+fp&#x27;</span><br><span class="line"> as -v -march=armv6 -mfloat-abi=hard -mfpu=vfp -meabi=5 -o /tmp/ccT9vuDF.o /tmp/ccr8xe6E.s</span><br><span class="line">GNU assembler version 2.35.2 (arm-linux-gnueabihf) using BFD version (GNU Binutils for Raspbian) 2.35.2</span><br><span class="line">COMPILER_PATH=/usr/lib/gcc/arm-linux-gnueabihf/10/:/usr/lib/gcc/arm-linux-gnueabihf/10/:/usr/lib/gcc/arm-linux-gnueabihf/:/usr/lib/gcc/arm-linux-gnueabihf/10/:/usr/lib/gcc/arm-linux-gnueabihf/</span><br><span class="line">LIBRARY_PATH=/usr/lib/gcc/arm-linux-gnueabihf/10/:/usr/lib/gcc/arm-linux-gnueabihf/10/../../../arm-linux-gnueabihf/:/usr/lib/gcc/arm-linux-gnueabihf/10/../../../:/lib/arm-linux-gnueabihf/:/lib/:/usr/lib/arm-linux-gnueabihf/:/usr/lib/</span><br><span class="line">COLLECT_GCC_OPTIONS=&#x27;-v&#x27; &#x27;-o&#x27; &#x27;test.out&#x27;  &#x27;-mfloat-abi=hard&#x27; &#x27;-mfpu=vfp&#x27; &#x27;-mtls-dialect=gnu&#x27; &#x27;-marm&#x27; &#x27;-march=armv6+fp&#x27;</span><br><span class="line"> /usr/lib/gcc/arm-linux-gnueabihf/10/collect2 -plugin /usr/lib/gcc/arm-linux-gnueabihf/10/liblto_plugin.so -plugin-opt=/usr/lib/gcc/arm-linux-gnueabihf/10/lto-wrapper -plugin-opt=-fresolution=/tmp/ccvxcalC.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -dynamic-linker /lib/ld-linux-armhf.so.3 -X --hash-style=gnu --as-needed -m armelf_linux_eabi -o test.out /usr/lib/gcc/arm-linux-gnueabihf/10/../../../arm-linux-gnueabihf/crt1.o /usr/lib/gcc/arm-linux-gnueabihf/10/../../../arm-linux-gnueabihf/crti.o /usr/lib/gcc/arm-linux-gnueabihf/10/crtbegin.o -L/usr/lib/gcc/arm-linux-gnueabihf/10 -L/usr/lib/gcc/arm-linux-gnueabihf/10/../../../arm-linux-gnueabihf -L/usr/lib/gcc/arm-linux-gnueabihf/10/../../.. -L/lib/arm-linux-gnueabihf -L/usr/lib/arm-linux-gnueabihf /tmp/ccT9vuDF.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/arm-linux-gnueabihf/10/crtend.o /usr/lib/gcc/arm-linux-gnueabihf/10/../../../arm-linux-gnueabihf/crtn.o</span><br><span class="line">COLLECT_GCC_OPTIONS=&#x27;-v&#x27; &#x27;-o&#x27; &#x27;test.out&#x27;  &#x27;-mfloat-abi=hard&#x27; &#x27;-mfpu=vfp&#x27; &#x27;-mtls-dialect=gnu&#x27; &#x27;-marm&#x27; &#x27;-march=armv6+fp&#x27;</span><br></pre></td></tr></table></figure><p>我们可以看到，在整个编译过程中使用到了<code>cc1</code>、<code>as</code>、<code>collect2</code>工具来完成<strong>预处理（Prepressing）-&gt;编译（Compilation）-&gt;汇编（Assembly）-&gt;链接（Linking）</strong>整个过程的。由此可知gcc是通过间接调用各种程序来完成编译（广义）过程，其中<code>cc1</code>完成了预处理和编译过程，<code>as</code>完成汇编过程，<code>collect2</code>完成链接过程。</p><ul><li><code>cc1</code>：也是通过间接调用<code>cpp</code>（C Pre-Processor）c预处理器进行预处理，自身进行编译</li><li><code>as</code>：汇编器，将汇编代码转化为机器码</li><li><code>collect2</code>：实际上的链接器是<code>ld</code>，gcc是通过调用<code>collect2</code>来间接调用<code>ld</code>进而进行链接的，感兴趣可以阅读[collect2](<a href="https://www.wanglianghome.org/2011/04/14/collect2/">collect2 | 懒惰的程序员 (wanglianghome.org)</a>)这边文章</li></ul><center class="half">    <img data-src="https://jesonblogbucket.oss-cn-shenzhen.aliyuncs.com/编译基本流程.png" width="800"/></center><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p><code>gcc -E test.c -o test.i</code>，参数<code>-E</code>表示只进行预处理，不进行后续操作，生成<code>test.i</code>文件。效果等同于使用预处理器<code>cpp</code></p><p>预处理后的结果如下，由于文本过长，只粘贴关键部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line"><span class="comment">/*中间是头文件stdio.h递归展开后的结果*/</span></span><br><span class="line"># <span class="number">5</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> kStaticInitVar = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> kStaticUnnitVar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s-var:%d\n&quot;</span>,__FUNCTION__, var);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> localStaticInitVar = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> localStaticUnintVar;</span><br><span class="line"></span><br><span class="line">    func(kStaticInitVar + localStaticInitVar + <span class="number">100</span>); <span class="comment">// DEF_VAR宏被替换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>预编译规则如下：</p><ul><li>替换所有宏定义</li><li>处理所有条件预编译指令，#if、#elif、#endif等等</li><li>递归展开所有用到的#include头文件包含指令</li><li>删除所有注释</li><li>添加行号以及文件标识，便于报错提示以及生成调试信息</li></ul><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><code>gcc -S test.i -o test.s</code>，参数<code>-S</code>表示只进行预处理、编译（狭义上）并生成汇编代码，当然可以用<code>test.c</code>生成汇编代码，使用<code>test.i</code>是因为其为预编译的产物，方便流程讲解。</p><p>编译过程主要包括这几个过程<strong>词法分析、语法分析、语义分析、优化代码</strong>。以下我只做总结概括，详情见：《程序员的自我修养-链接、装载与库》-2.2章节：</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>由扫描器扫描源代码，将<strong>关键字、标识符、字面量、操作符</strong>进行归纳和分类，并存储到表中，供<strong>语法分析</strong>环节使用。</p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>把扫描器产生的记号生成以<strong>表达式</strong>为节点的<strong>语法树</strong>，整个分析过程采用了<strong>上下文无关语法（Context-free Grammar）</strong>（感兴趣可以深入了解，工作中基本用不上）。通过了<strong>语法分析</strong>并不代表代码过关了，此过程只是确认最小表达式是否符合语法。</p><p><strong>此图引用至《程序员的自我修养-链接、装载与库》，侵删~</strong></p><center class="half">    <img data-src="https://jesonblogbucket.oss-cn-shenzhen.aliyuncs.com/链接与库-语法树.jpg" width="800"/>    <br> 程序员的自我修养-链接、装载与库-语法树</center><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>只进行语法分析是远远不够的，好比每个词语都没问题，但是不按照语法进行有意义的组合拿别人就无法理解。编译器也一样，例如两个指针的乘法运算是无意义的。</p><p>语义分析分为<strong>静态语义</strong>和<strong>动态语义</strong>。静态语义是指编译期可以确定的，动态语义指的是在运行时候才能确定的语义。</p><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p><strong>编译器通过分析源代码，识别出其中可以进行优化的部分, 并进行调整以改善程序性能</strong>，常见的优化例如<strong>常量传播、常量折叠</strong>，在c++中的有<strong>返回值优化（RVO）</strong>等，当然编译器所作的优化是有限的~</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p><code>gcc test.s -o test.o</code>表示将汇编代码转化为机器码，也等同于<code>gcc -c test.c -o test.o</code></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接过程本质上就是将引用的外部符号进行地址修正的过程~`test.c<code>中并没有实现</code>printf<code>函数。我们用[nm](https://www.man7.org/linux/man-pages/man1/nm.1.html)命令来看看</code>test.o<code>的符号列表，</code>nm -a test.o`</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">00000000 n .ARM.attributes</span><br><span class="line">00000000 b .bss</span><br><span class="line">00000000 n .comment</span><br><span class="line">00000000 d .data</span><br><span class="line">00000000 T func</span><br><span class="line">0000000c r __FUNCTION__.2</span><br><span class="line">00000000 d kStaticInitVar</span><br><span class="line">00000000 b kStaticUnnitVar</span><br><span class="line">00000004 d localStaticInitVar.1</span><br><span class="line">00000004 b localStaticUnintVar.0</span><br><span class="line">00000034 T main</span><br><span class="line">00000000 n .note.GNU-stack</span><br><span class="line">         U printf</span><br><span class="line">00000000 r .rodata</span><br><span class="line">00000000 a test.c</span><br><span class="line">00000000 t .text</span><br></pre></td></tr></table></figure><p>其中<code>printf</code>符号的状态是U，表示符号在当前文件中是未定义的。然后执行下面命令生成<code>test.out</code>：</p><p><strong>注意：下面命令只是用于与我拥有相同环境，下面命令只是我在<code>collect2</code>命令基础上将参数<code>/tmp/ccT9vuDF.o</code>替换为<code>test.o</code></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/gcc/arm-linux-gnueabihf/10/collect2 -plugin /usr/lib/gcc/arm-linux-gnueabihf/10/liblto_plugin.so -plugin-opt=/usr/lib/gcc/arm-linux-gnueabihf/10/lto-wrapper -plugin-opt=-fresolution=/tmp/ccvxcalC.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -dynamic-linker /lib/ld-linux-armhf.so.3 -X --hash-style=gnu --as-needed -m armelf_linux_eabi -o test.out /usr/lib/gcc/arm-linux-gnueabihf/10/../../../arm-linux-gnueabihf/crt1.o /usr/lib/gcc/arm-linux-gnueabihf/10/../../../arm-linux-gnueabihf/crti.o /usr/lib/gcc/arm-linux-gnueabihf/10/crtbegin.o -L/usr/lib/gcc/arm-linux-gnueabihf/10 -L/usr/lib/gcc/arm-linux-gnueabihf/10/../../../arm-linux-gnueabihf -L/usr/lib/gcc/arm-linux-gnueabihf/10/../../.. -L/lib/arm-linux-gnueabihf -L/usr/lib/arm-linux-gnueabihf test.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/arm-linux-gnueabihf/10/crtend.o /usr/lib/gcc/arm-linux-gnueabihf/10/../../../arm-linux-gnueabihf/crtn.o</span><br></pre></td></tr></table></figure><p>查看<code>test.out</code>符号，<code>nm -a test.out</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">00000000 a</span><br><span class="line">         U abort@GLIBC_2.4</span><br><span class="line">000104e8 r all_implied_fbits</span><br><span class="line">0001058c r all_implied_fbits</span><br><span class="line">00000000 n .ARM.attributes</span><br><span class="line">0001061c r .ARM.exidx</span><br><span class="line">00021030 b .bss</span><br><span class="line">0002103c B __bss_end__</span><br><span class="line">0002103c B _bss_end__</span><br><span class="line">00021030 B __bss_start</span><br><span class="line">00021030 B __bss_start__</span><br><span class="line">00010354 t call_weak_fn</span><br><span class="line">00000000 n .comment</span><br><span class="line">00021030 b completed.0</span><br><span class="line">00000000 a crtstuff.c</span><br><span class="line">00000000 a crtstuff.c</span><br><span class="line">00021020 d .data</span><br><span class="line">00021020 D __data_start</span><br><span class="line">00021020 W data_start</span><br><span class="line">00010378 t deregister_tm_clones</span><br><span class="line">000103dc t __do_global_dtors_aux</span><br><span class="line">00020f14 d __do_global_dtors_aux_fini_array_entry</span><br><span class="line">00021024 D __dso_handle</span><br><span class="line">00020f18 d .dynamic</span><br><span class="line">00020f18 d _DYNAMIC</span><br><span class="line">00010230 r .dynstr</span><br><span class="line">000101e0 r .dynsym</span><br><span class="line">00021030 D _edata</span><br><span class="line">00010624 r .eh_frame</span><br><span class="line">00000000 a elf-init.oS</span><br><span class="line">0002103c B __end__</span><br><span class="line">0002103c B _end</span><br><span class="line">000104dc t .fini</span><br><span class="line">000104dc T _fini</span><br><span class="line">00020f14 d .fini_array</span><br><span class="line">00010404 t frame_dummy</span><br><span class="line">00020f10 d __frame_dummy_init_array_entry</span><br><span class="line">00010624 r __FRAME_END__</span><br><span class="line">00010408 T func</span><br><span class="line">00010584 r __FUNCTION__.2</span><br><span class="line">00021000 d _GLOBAL_OFFSET_TABLE_</span><br><span class="line">         w __gmon_start__</span><br><span class="line">000101b4 r .gnu.hash</span><br><span class="line">00010274 r .gnu.version</span><br><span class="line">00010280 r .gnu.version_r</span><br><span class="line">00021000 d .got</span><br><span class="line">000102c8 t .init</span><br><span class="line">000102c8 T _init</span><br><span class="line">00020f10 d .init_array</span><br><span class="line">00020f14 d __init_array_end</span><br><span class="line">00020f10 d __init_array_start</span><br><span class="line">00010154 r .interp</span><br><span class="line">000104e4 R _IO_stdin_used</span><br><span class="line">00021028 d kStaticInitVar</span><br><span class="line">00021034 b kStaticUnnitVar</span><br><span class="line">000104d8 T __libc_csu_fini</span><br><span class="line">00010478 T __libc_csu_init</span><br><span class="line">         U __libc_start_main@GLIBC_2.4</span><br><span class="line">0002102c d localStaticInitVar.1</span><br><span class="line">00021038 b localStaticUnintVar.0</span><br><span class="line">0001043c T main</span><br><span class="line">00010194 r .note.ABI-tag</span><br><span class="line">00010170 r .note.gnu.build-id</span><br><span class="line">000102d4 t .plt</span><br><span class="line">         U printf@GLIBC_2.4</span><br><span class="line">000103a4 t register_tm_clones</span><br><span class="line">000102a0 r .rel.dyn</span><br><span class="line">000102a8 r .rel.plt</span><br><span class="line">000104e4 r .rodata</span><br><span class="line">00010318 T _start</span><br><span class="line">00000000 a test.c</span><br><span class="line">00010318 t .text</span><br><span class="line">00021030 D __TMC_END__</span><br><span class="line">00000000 a /usr/lib/gcc/arm-linux-gnueabihf/10/../../../arm-linux-gnueabihf/crt1.o</span><br><span class="line">00000000 a /usr/lib/gcc/arm-linux-gnueabihf/10/../../../arm-linux-gnueabihf/crti.o</span><br><span class="line">00000000 a /usr/lib/gcc/arm-linux-gnueabihf/10/../../../arm-linux-gnueabihf/crtn.o</span><br></pre></td></tr></table></figure><p>我们对比一下可以很容易发现一些变化：</p><ol><li><strong><code>printf</code>符号变成了<code>printf@GLIBC_2.4</code>且还是未定义</strong>：此符号gcc在链接时根据当前版本修改符号，使得在运行程序而动态链接时不会链接到其他gcc版本的<code>printf</code></li><li><strong>很多符号的地址都被修正了，符号<code>func</code>符号地址从00000000被修正为00010408</strong>：单独模块(*.o或者*.obj)的编译时编译器并不知道<code>func</code>的地址</li><li><strong>符号增多</strong>：目标文件和可执行文件elf文件格式存在差异，例如增加了<code>.dynamic</code>段相关信息，即动态链接信息</li><li>其他（有时间再研究研究）</li></ol><p>当前演示的链接过程并不是<strong>静态链接</strong>。如果需要进行静态链接则需要加上<code>-static</code>参数。静态链接比较简单，说白了就是递归的将所有引用到的符号归档到一个文件中，因此静态链接后的文件都会大上许多~经常与静态链接一起提及的就是<strong>动态链接</strong>。动态链接的链接时期是程序运行时，当前链接环节可以理解为为动态链接做准备。</p><p><strong>静态链接和动态链接最主要的区别：两者的链接时期不一致，静态链接在程序编译链接时期，动态链接则是程序运行时</strong></p><p>这里可以说内容比较多，现在只是简单提一嘴，后续会有专门的文章来聊聊这两者具体的差异以及各自的机制~</p><p>最后总结一下链接过程：</p><ul><li><p>链接器就是在链接的时候自动在所提供的依赖库或者目标文件（*.o或者*.obj）中搜索被引用的外部符号</p></li><li><p>找到之后会将绝对地址指令重新修正，使其指向正确的地址。</p></li><li><p>修正的过程被称之为<strong>重定位</strong>，被修正的地址入口称之为<strong>重定位入口</strong></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为工作需要，最近需要搭建跨平台工程。其中涉及到了依赖库交叉编译等工作。&lt;br&gt;因此趁这个机会写一个关于c/c++编译器的工作机制的小系列，&lt;/p&gt;</summary>
    
    
    
    <category term="编译基本原理" scheme="https://jesonwoo.github.io/categories/%E7%BC%96%E8%AF%91%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="编译原理" scheme="https://jesonwoo.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>CPP11-右值引用</title>
    <link href="https://jesonwoo.github.io/2022/02/11/CPP11-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <id>https://jesonwoo.github.io/2022/02/11/CPP11-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</id>
    <published>2022-02-11T07:05:38.000Z</published>
    <updated>2022-02-14T09:16:35.980Z</updated>
    
    <content type="html"><![CDATA[<p>右值引用是cpp11引入的很重要的特性，是为了支持一下两个特性而引入的：</p><ol><li>去除不必要的对象内存拷贝，<strong>极大提高了程序运行效率</strong></li><li>在泛型中支持完美转发（Perfect Forwarding），<strong>提升编程效率</strong></li></ol><span id="more"></span><p><strong>说在前面：一下所有代码均在g++编译器上进行编译并验证过的</strong></p><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>我们先来看看它和左值引用的区别</p><ul><li>左值：<code>int a = 1;</code>其中a就是左值，那种非临时的对象即有分配内存且有名字的对象就是左值</li><li>右值：<code>A a = A(100);</code>其中A(100)就是右值，那种临时对象且之作用于单条语句的对象就是右值。右值也可以称之为“将亡值”即即将销毁的对象<br>总的来说，一个是临时对象，一个是非临时对象。cpp11引入了这个特性为了做好左值和右值的区分。那做好区分了之后呢？有什么作用呢？这个就需要讲到<strong>移动语义</strong>了</li></ul><h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p>移动语义也叫转移语义，移动语义可以将对象内的内存资源管理权转移到另外一个对象中。移动语义和拷贝语义是相对应的，这两者的区别跟拷贝和剪切的区别一样。因此，<strong>移动语义的效率要高于拷贝语义</strong>。</p><p>为了方便理解，我们可以将<strong>移动拷贝构造</strong>对应<strong>浅拷贝</strong>，<strong>拷贝构造</strong>对应<strong>深拷贝</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">const</span> A&amp;) &#123; cout &lt;&lt; <span class="string">&quot;A(const A&amp;)&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// 拷贝构造</span></span><br><span class="line">        <span class="built_in">A</span>(A&amp;&amp;) &#123; cout &lt;&lt; <span class="string">&quot;A(A&amp;&amp;)&quot;</span> &lt;&lt; endl; &#125;      <span class="comment">// 移动拷贝构造</span></span><br><span class="line">        <span class="function">A <span class="title">self</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(a.self())</span></span>;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行，输出如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">A</span>()</span><br><span class="line"><span class="built_in">A</span>(<span class="keyword">const</span> A&amp;)</span><br><span class="line"><span class="built_in">A</span>(<span class="keyword">const</span> A&amp;)</span><br></pre></td></tr></table></figure><p>发现输出不符合预期，没有调用移动拷贝构造函数。是因为编译器进行了返回值优化（RVO），需要加上编译参数<code>-fno-elide-constructors</code>来关闭RVO。<strong>注意：visual studio无法关闭返回值优化，测试可使用g++编译器</strong><br>加上<code>-fno-elide-constructors</code>参数后编译执行，输出如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">A</span>()</span><br><span class="line"><span class="built_in">A</span>(<span class="keyword">const</span> A&amp;)</span><br><span class="line"><span class="built_in">A</span>(<span class="keyword">const</span> A&amp;)</span><br><span class="line"><span class="built_in">A</span>(A&amp;&amp;)</span><br></pre></td></tr></table></figure><p>看了上面的例子，很容易会发现一个很别扭的写法。为什么要这样<code>A a2(a.self());</code>通过调用<code>A::self</code>获取<code>a</code>对象而不直接使用<code>a</code>进行传参？这不是多此一举了？当然这是为了演示使用临时对象（将亡值）构造A对象而取了巧哈哈哈。那有什么方式可以不需要这么麻烦呢？<br>其实cpp11提供了<code>std::move</code>函数来解决这个问题！调用这个函数并没有任何移动，内部实现只是做了一个类型转化，使其可以将左值引用转化为右值引用。最终<code>a2</code>对象的构造可以改为<code>A a2(std::move(a));</code></p><p><code>std::move</code>的实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FUNCTION TEMPLATE std::move</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class _Ty&gt; _NODISCARD <span class="keyword">constexpr</span> <span class="keyword">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; <span class="title">move</span><span class="params">(_Ty&amp;&amp; _Arg)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// forward _Arg as movable</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp;&gt;(_Arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是要注意的是<strong>执行<code>A a2(std::move(a));</code>后，对象<code>a</code>的内存就托管给<code>a2</code>，所以对象<code>a</code>成为了无效对象。 在往后的编程中要注意没有必要则不要滥用<code>std::move</code>，例如对于一些临时对象就没有必要使用<code>std::move</code>。</strong></p><h2 id="完美转发（Perfect-Forwarding）"><a href="#完美转发（Perfect-Forwarding）" class="headerlink" title="完美转发（Perfect Forwarding）"></a>完美转发（Perfect Forwarding）</h2><p>我们先来看看完美转发的使用场景，在讲具体场景前我们先来看看下面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">concat</span><span class="params">(<span class="keyword">const</span> string&amp; a, <span class="keyword">const</span> string&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; (a + b).<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FUNC, <span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FUNC f, <span class="keyword">const</span> A&amp; a, <span class="keyword">const</span> B&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">invoke</span>(sum, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">invoke</span>(concat, <span class="string">&quot;Hello &quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure><p>一切正常，完美~但是如果这时我们需要增加一个方法，那问题就来了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> &amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b = ++a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用同样的方法进行调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">invoke</span>(increase, a, b);</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>会发现g++编译报错<code>error: binding reference of type ‘int&amp;’ to ‘const int’ discards qualifiers</code>。<strong>注：vs2017是编译通过并且结果是符合预期，还未深究是否是编译器进行了优化还是cpp17的特性。</strong></p><p>如果在没有<code>完美转发（Perfect Forwarding）</code>特性之前我们是如何解决这个问题的呢？很简单，针对这种情况再重载一个方法就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FUNC, <span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FUNC f, <span class="keyword">const</span> A&amp; a, B&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果我们还需要支持<code>&amp;, const &amp;</code>, <code>&amp;, &amp;</code>类型的参数呢？我们来看看重载后的效果~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FUNC, <span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FUNC f, <span class="keyword">const</span> A&amp; a, <span class="keyword">const</span> B&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FUNC, <span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FUNC f, A&amp; a, <span class="keyword">const</span> B&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FUNC, <span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FUNC f, <span class="keyword">const</span> A&amp; a, B&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FUNC, <span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FUNC f, A&amp; a, B&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信你已经意识到问题在哪了~如果我们到支持N个参数，就需要重载<code>2^N</code>个方法，这对于开发人员来说就是噩梦！！<br>这时<code>完美转发（Perfect Forwarding）</code>就应运而生了哈哈，那我们来看看该如何改造</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FUNC, <span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FUNC f, A&amp;&amp; a, B&amp;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造之后可以正常运行，且代码明显精简很多了哈哈，<strong>但实际上，上面改造还存在问题！！</strong></p><p>首先我们来回顾一个知识点，请问：<code>void invoke(FUNC f, A&amp;&amp; a, B&amp;&amp; b)</code>中的a是左值引用还是右值引用？<br>相信大部分同学会脱口而出<strong>右值引用</strong>，因为类型是<code>A&amp;&amp;</code>。很好~可惜回答错误，<strong>a是一个左值引用</strong>!</p><p>我在再来看看左值引用的定义：</p><blockquote><p>非临时的对象即有分配内存且有名字的对象就是左值</p></blockquote><p>因此，如果我们需要转发一个右值引用时，上面的改造显然是不够的，这时候我们就需要引入一个转发的重量级方法<code>std::forward</code><br>最终改造如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FUNC, <span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FUNC f, A&amp;&amp; a, B&amp;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(std::forward&lt;A&gt;(a), std::forward&lt;B&gt;(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看<code>std::forwark</code>的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class _Ty&gt;</span></span><br><span class="line"><span class="function">_NODISCARD <span class="keyword">constexpr</span> _Ty&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; _Arg)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// forward an rvalue as an rvalue</span></span><br><span class="line">        <span class="built_in"><span class="keyword">static_assert</span></span>(!is_lvalue_reference_v&lt;_Ty&gt;, <span class="string">&quot;bad forward call&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::forward</code>也只是做了类型转换，为什么<code>A&amp;&amp;</code>可以实现完美转发呢？这里面就涉及到两个概念<code>万能引用</code>和<code>引用折叠</code></p><h3 id="万能引用"><a href="#万能引用" class="headerlink" title="万能引用"></a>万能引用</h3><p><code>T&amp;&amp;</code>就是一个万能引用，即可以接受任何类型的参数，<code>T</code>为模板类型T。我们都知道<code>T</code>是一个类型占位符，因此<code>T</code>可以是<code>&amp;&amp;</code>、<code>&amp;</code>、<code>const &amp;</code>等。进而可以知道会推导成<code>T&amp;&amp; &amp;&amp;</code>、<code>T&amp; &amp;&amp;</code>、<code>const T&amp; &amp;&amp;</code>。我们都知道cpp编译器是不允许构建引用的引用这个类型的，那这些<code>T&amp;&amp; &amp;&amp;</code>、<code>T&amp; &amp;&amp;</code>、<code>const T&amp; &amp;&amp;</code>是什么呢？这就是我们下面要介绍的<strong>引用折叠</strong>的内容</p><h3 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h3><p>这些“引用的引用”就是cpp11编译器在推导<code>万能引用</code>的具体类型时的中间状态，具体推导规则如下</p><table><thead><tr><th>中间状态</th><th>推导类型</th></tr></thead><tbody><tr><td>T&amp; &amp;&amp;</td><td>T&amp;</td></tr><tr><td>T&amp;&amp; &amp;</td><td>T&amp;</td></tr><tr><td>T&amp; &amp;</td><td>T&amp;</td></tr><tr><td>T&amp;&amp; &amp;&amp;</td><td>T&amp;&amp;</td></tr></tbody></table><p>有了以上的推导规则构成完美转发的基础</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://oopscenities.net/2014/02/01/c11-perfect-forwarding/">C++11: Perfect forwarding | De C++ et alias OOPscenitates</a></li><li><a href="https://zhuanlan.zhihu.com/p/161039484">聊聊C++中的完美转发 - 知乎</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;右值引用是cpp11引入的很重要的特性，是为了支持一下两个特性而引入的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;去除不必要的对象内存拷贝，&lt;strong&gt;极大提高了程序运行效率&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在泛型中支持完美转发（Perfect Forwarding），&lt;strong&gt;提升编程效率&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="CPP" scheme="https://jesonwoo.github.io/categories/CPP/"/>
    
    <category term="CPP11" scheme="https://jesonwoo.github.io/categories/CPP/CPP11/"/>
    
    
    <category term="CPP11" scheme="https://jesonwoo.github.io/tags/CPP11/"/>
    
  </entry>
  
  <entry>
    <title>CPP11-初始化列表</title>
    <link href="https://jesonwoo.github.io/2022/01/28/CPP11-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/"/>
    <id>https://jesonwoo.github.io/2022/01/28/CPP11-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/</id>
    <published>2022-01-28T07:02:31.000Z</published>
    <updated>2022-01-28T08:46:41.681Z</updated>
    
    <content type="html"><![CDATA[<p>在CPP11之前的不同对象都有各自的初始化方式，于是初始化列表特性的目的在于统一初始化环节</p><span id="more"></span><h2 id="统一初始化"><a href="#统一初始化" class="headerlink" title="统一初始化"></a>统一初始化</h2><p>提供了基本类型、数组、自定义类型等不同对象的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(string name, <span class="keyword">int</span> age) </span><br><span class="line">        : <span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age) &#123;</span><br><span class="line">        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">&quot;Jeson&quot;</span>, <span class="number">18</span>)</span></span>;    <span class="comment">// 传统方式</span></span><br><span class="line">Student s2&#123; <span class="string">&quot;Mark&quot;</span>, <span class="number">18</span> &#125;;   <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a1 &#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2 = &#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> * arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>]&#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure><p><font color=red>注意事项：自定义类型是尽量实现对应的构造函数，虽然初始化列表支持使用默认构造按照声明顺序进行初始化，但是从开发规范的角度来说，这种方式容易产生隐藏bug，不易排查</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student s1&#123; <span class="string">&quot;Jeson&quot;</span>, <span class="number">18</span> &#125;;    <span class="comment">// 编译通过; s1.m_name == Jeson ; s1.m_age == 18</span></span><br><span class="line">Student s2&#123; <span class="number">18</span>, <span class="string">&quot;Jeson&quot;</span> &#125;;    <span class="comment">// 编译不通过</span></span><br></pre></td></tr></table></figure><h2 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h2><p>初始化列表可以防止”缩窄”的隐式类型转换，对于小到大的则不做限制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1 = <span class="number">3.14</span>;   <span class="comment">// 编译通过</span></span><br><span class="line"><span class="keyword">int</span> a2 = &#123;<span class="number">3.14</span>&#125;; <span class="comment">// 编译不过，vs2017报错（error C2397: 从“double”转换到“int”需要收缩转换）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> b1 = <span class="number">3</span>;   <span class="comment">// 编译通过</span></span><br><span class="line"><span class="keyword">double</span> b2 = &#123;<span class="number">3</span>&#125;; <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure><h2 id="初始化模板类-std-initializer-list"><a href="#初始化模板类-std-initializer-list" class="headerlink" title="初始化模板类-std::initializer_list"></a>初始化模板类-std::initializer_list</h2><p>cpp11提供了<code>std::initializer_list</code>模板类，可将其作为构造函数的参数，如果类有接受initializer_list作为参数的构造函数，则初始化列表语法就只能用于该构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(std::initializer_list&lt;<span class="keyword">int</span>&gt; list) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(std::initializer_list&lt;int&gt; list)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(int a, int b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a1&#123; <span class="number">1</span>, <span class="number">2</span> &#125;;    <span class="comment">// A(std::initializer_list&lt;int&gt; list)</span></span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;      <span class="comment">// A(int a, int b)</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《C++ Primer Plus（第6版）中文版》</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在CPP11之前的不同对象都有各自的初始化方式，于是初始化列表特性的目的在于统一初始化环节&lt;/p&gt;</summary>
    
    
    
    <category term="CPP" scheme="https://jesonwoo.github.io/categories/CPP/"/>
    
    <category term="CPP11" scheme="https://jesonwoo.github.io/categories/CPP/CPP11/"/>
    
    
    <category term="CPP11" scheme="https://jesonwoo.github.io/tags/CPP11/"/>
    
  </entry>
  
  <entry>
    <title>常用排序算法总结</title>
    <link href="https://jesonwoo.github.io/2021/12/21/%E7%AE%97%E6%B3%95-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://jesonwoo.github.io/2021/12/21/%E7%AE%97%E6%B3%95-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-12-21T15:17:02.000Z</published>
    <updated>2022-01-27T07:10:44.767Z</updated>
    
    <content type="html"><![CDATA[<p>学习排序算法时的总结和记录</p><span id="more"></span><h2 id="各种排序算法比较"><a href="#各种排序算法比较" class="headerlink" title="各种排序算法比较"></a>各种排序算法比较</h2><table><thead><tr><th>排序</th><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>直接插入排序</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td>根据增量序列的不同时间复杂度不同；可以很接近<strong>O(nlogn)</strong></td><td>O(1)</td><td>不稳定</td></tr><tr><td>冒泡排序</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>快速排序</td><td>期望值O(nlogn),需要考虑数组几乎有序和存在大量重复元素的情况</td><td>O(1)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(n)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(n)</td><td>不稳定</td></tr></tbody></table><h2 id="直接插入排序（InsertSort）"><a href="#直接插入排序（InsertSort）" class="headerlink" title="直接插入排序（InsertSort）"></a>直接插入排序（InsertSort）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(T* arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[idx]) &#123;</span><br><span class="line">                idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[idx]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序（ShellSort）"><a href="#希尔排序（ShellSort）" class="headerlink" title="希尔排序（ShellSort）"></a>希尔排序（ShellSort）</h2><h3 id="普通希尔排序"><a href="#普通希尔排序" class="headerlink" title="普通希尔排序"></a>普通希尔排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(T* arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            T tmp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; tmp; j -= gap) &#123;</span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化希尔排序（调整increment-sequence）"><a href="#优化希尔排序（调整increment-sequence）" class="headerlink" title="优化希尔排序（调整increment sequence）"></a>优化希尔排序（调整increment sequence）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; n / <span class="number">3</span>)</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// h-sort the array</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序</span></span><br><span class="line">            T e = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= h &amp;&amp; e &lt; arr[j - h]; j -= h)</span><br><span class="line">                arr[j] = arr[j - h];</span><br><span class="line">            arr[j] = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序（BubbleSot）"><a href="#冒泡排序（BubbleSot）" class="headerlink" title="冒泡排序（BubbleSot）"></a>冒泡排序（BubbleSot）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSot</span><span class="params">(T* arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序的优化"><a href="#冒泡排序的优化" class="headerlink" title="冒泡排序的优化"></a>冒泡排序的优化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * 用一个变量flag记录下最后一个发生交换的位置，后面没有发生交换的已经有序 </span></span><br><span class="line"><span class="comment">// * 所以可以用这个值来作为下一次比较结束的位置 </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSot</span><span class="params">(T *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = n;</span><br><span class="line">    <span class="keyword">int</span> j, k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flag; i++) &#123;</span><br><span class="line">        k = flag; <span class="comment">//保存最后一次交换的位置下标</span></span><br><span class="line">        flag = <span class="number">0</span>; <span class="comment">//如果flag值不变则说明之后的数据有序，因此可退出程序</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                flag = j;</span><br><span class="line">                <span class="built_in">swap</span>(arr[j], arr[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序（QuickSort）"><a href="#快速排序（QuickSort）" class="headerlink" title="快速排序（QuickSort）"></a>快速排序（QuickSort）</h2><h3 id="普通快排"><a href="#普通快排" class="headerlink" title="普通快排"></a>普通快排</h3><p>​    快排核心步骤就是partition操作，partition操作一般情况下就是以arr[l]元素（记为tmp）为基准将arr分为大于tmp和小于tmp两部分 ， 最终将其分为 arr[l … j] &lt; tmp和arr[j+1 … r] &gt; tmp两部分</p><p><img data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARkAAACBCAIAAAB7MFnaAAAAA3NCSVQICAjb4U/gAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAFIklEQVR4nO3dy3HbMBSFYTGTCrJ0C3ID2bgbV+VU47RAteDs0gKz4ISDAQkIIA4I8PL/VnpQN5DCYzxIUcM0TTcAxb61bgBgBFkCNMgSoEGWAA2yBGiQJUCDLAEaZAnQIEuABlkCNMgSoEGWAA2yBGiQJUDje+4LHo9HjXYY8/r62roJRxjHsXUT6rrf7xlbTznGccza/rKldny256J9gx3+D+4oxRgP0CBLbQzD8PSRw4p7zy53hU26guz5EiSmaRqGYfo/WHJvu7xtQqUqNRJZyNKhQj2Ad3tyJiRLnNaZCSUQTZClQ7m7fkq/tDZHzuvW4ht7t0Ov2uz3nr4KC7J0tHgG1s9u3n0apHmDdVZDPWFoMEmE0pGlo0W6lKcxC91dZyal49rRKyKCLB1n3SdEHpnDsNz2brAm0SGydJzcnXs9KqtnDmdoMZ1YpiBLDUTi8XQWFCniDdXiR428bs1dKmS+tA9ZaiM0X0p81eYYL7JosTkjcpcEM5qOAM57sC80fnMX+lCOfqmNfV1BfIxXiONLhchSGzXGeJvSV8k5vlSIMd6JMc/pCv1SG4kxWKY6m+sKT7sa79n19hylFSJLbaSM8bzh2XoD91WJZ74updJPj0AislRRpPMJPRU5USjr34pkb7195PtODCPT5f1N4mIPibjegw1c74FSlGpQinU8QIMsARpkCdAgS4AGWQI0yBKgQZYADbIEaJAlQIMsARpkCdAgS4AGWQI0yBKgQZYADbIEaJAlQCP7uhm/fv+p1JQSP3/8bd0EGJT1HXUj107J+15+2OPxoBSlllJZ2zPGAzTIEqBBlgANsgRoGFl7iOBXT3AM+/3SfB3A1q2AffazBByDLAEadedL728vy+2Pzy/3kY/Pr5TbVZuHS3FnzjVm0RWz9P724oZhvrskanl2Tk7ocUBljs0wDMtPTml/EadiluKRWGLmdT6hxwGVpS/SLkpVH+MtkaCfgW0V1x68MR5gG+t4gEbd+ZI3rnPvuksO7lPe4+W8n17luO1l1d4T6s6X0iNRbzRIeDCrvScwxgM0Tn9u6zwmfG/dDJiU1ZXRLwEaeddO6fB7+cJ5JKUoVVKKfgnQIEuABlkCNMgSoHH6NfEU7qn1hRNTVan12f6qap28QUmp5csRm5V3Ny9UtpD9LHkfXMnnKCx10x2G7/MNFpaKfLPI/fZRbvO0X1jyMMZDj0JXvHHz4349trCshP0sCXsSpLvgx25/jDeTHMWT7x+qVpUMe7xSbts6eYNncZUsSXY1LVUAbs5op593N+vwY6/H/hjPtWOEvUmy95eM+zfbo3p3N/XeL2xYz66VJYne/soWTsfjBZHOfpa0fxFV+1m3f6fNv8F67GfJVbijrI+ZKBrVUT/Q/xt0O95+PreZ/bUH7UU6VbuXsFXeuE54skKJwjcYuTZDyUJL1Us+2M/STfeRaT967eS+qzrl1eKv3V25aj92rTEeUI+Rfkk406UUpfbJzlLuD7UfUwpob8oxjmPW9pSi1HVKMV8CNMgSoEGWAA2yBGhcKEvzjyv2UAQmXShLQFVGjtWmmBTnj0iKwCT6JUDjKv2S5KRs4fnmsOcq/dJ8ZLqHIrDqKlkCaiNLgAZZAjTIEqBxlXU8iapXC8DZ2c+S9iI4kjowyX6WbhwXwiGyf0e9XlOA3tzv9/SN+7paH3BerOMBGmQJ0CBLgAZZAjTIEqBBlgANsgRokCVAgywBGmQJ0CBLgAZZAjTIEqBBlgCNfzoo093eocOXAAAAAElFTkSuQmCC" alt="partition"></p><h4 id="各个变量定义"><a href="#各个变量定义" class="headerlink" title="各个变量定义"></a>各个变量定义</h4><ul><li><p>l：arr左边界</p></li><li><p>r：arr有边界</p></li><li><p>i：准备进行判断比较的位置</p></li><li><p>j：<code>arr[l ... j] &lt; tmp</code>，一开始 <code>j == l</code> 时表示没有元素小于tmp</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> _Partition(T* arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = l;</span><br><span class="line">    T tmp = arr[l];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; tmp) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[j + <span class="number">1</span>], arr[i]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[j], arr[l]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="普通快排的缺陷"><a href="#普通快排的缺陷" class="headerlink" title="普通快排的缺陷"></a>普通快排的缺陷</h4><ul><li>当数组近乎有序的时候,算法会退化成O(n^2)级别的算法</li></ul><p>​    采用随机选择一个标定元素，则该排序的期望值为O(nlogn)，大概率上避免退化成O(n^2)；在partition一开始的位置<code> swap(arr[l], arr[(rand() % (r - l + 1)) + l]);</code></p><ul><li>当存在大量重复元素的时候,算法也会退化成O(n^2)<h4 id="普通快排的优化"><a href="#普通快排的优化" class="headerlink" title="普通快排的优化"></a>普通快排的优化</h4>​</li><li>将整个数组通过标定元素比较分成三个部分，小于标定，等于标定，大于标定因此如果存在大量重复元素也能高效执行算</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> _QuickSort3(T* arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    <span class="comment">// 当元素少于16个时，使用插入排序作为快速排序的自排序更为高效</span></span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="built_in">InsertSort</span>(arr + l, r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(arr[l], arr[(<span class="built_in">rand</span>() % (r - l + <span class="number">1</span>)) + l]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = arr[l];</span><br><span class="line">    <span class="keyword">int</span> lt  = l;     <span class="comment">// arr[l...lt] &lt; tmp</span></span><br><span class="line">    <span class="keyword">int</span> gt  = r + <span class="number">1</span>; <span class="comment">// arr[gt...r] &gt; tmp</span></span><br><span class="line">    <span class="keyword">int</span> i   = l + <span class="number">1</span>; <span class="comment">// arr[lt+1...i-1] == tmp</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (gt &gt; i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; tmp) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[++lt], arr[i++]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; tmp) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[--gt], arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// tmp == arr[i]</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(arr[lt], arr[l]);</span><br><span class="line"></span><br><span class="line">    _QuickSort3(arr, l, lt - <span class="number">1</span>);</span><br><span class="line">    _QuickSort3(arr, gt, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort3</span><span class="params">(T* arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    _QuickSort3(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序（MergeSort）"><a href="#归并排序（MergeSort）" class="headerlink" title="归并排序（MergeSort）"></a>归并排序（MergeSort）</h2><h3 id="Merge操作"><a href="#Merge操作" class="headerlink" title="Merge操作"></a>Merge操作</h3><p><img data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUgAAAEZCAIAAAB6pCs2AAAAA3NCSVQICAjb4U/gAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAOSElEQVR4nO3dWWwc9R3A8f941+v7WJs4R3PgXL5iSAOEJpQkODQkSC2orYpUqaRSCX2n6kuFelBeWlWgVhRVmL6kVSX6AhUPDknjQAIKhYYQspvYOchh4zgJ3l1f8bmePizZbjaJ7Yln5z/zm+9HUbQx67//aP31zPx3PGOYpqkAyJKnewIA7EfYgECEDQhE2IBAhA0IRNiAQIQNCETYgECEDQhE2IBAhA0IRNiAQIQNCETYgEBBq58QjUZzMQ+fWLNmje4pCBGJRHRPwWlNTU2zf7K1sKPRqKXRGfCW+B34uTAMQ1n8Lp+R+79trG5Q2RUHBCJsQCDCBgQibEAgwgYEImxAIMIGBCJsaYzrXn/9dSOD7nnBUYQtzS3PfuGUGL8hbEAgwgYEImzfMW6U9cGdO3fe8sjcuMn0A0IvwpaptbV1165dra2tWR9PhWdel/URpdTu3bvVTcfkWc/JfMLtBoRehO1H02xdn3766VSfmRnPZUBoYfn3sSGA1UVy0zQzu73501l1dxvCxszS+9u6J4LZImxfm2WxWVvsaT6FHwEuwTG2NLc80M3ai848JM78iFJq9+7dNx8tT7NCdrsBoRdbbGnSXT3zzDPpv2/5hBk/aPUrwj0IGzOb/a44XIKwMSuU7C0cYwMCscXWgBM5kGuGpV0s7hYwR9wwwC7cMGAGphWRSMTS8xmQARlQy4AcYwMCETYgEGEDAhE2IBBhAwIRNiAQYQMCETYgEGEDAhE2IBBhAwIRNiAQYQMCETYgEGEDAhE2IBBhAwIRNiAQYQMCETYgEGEDAhE2IBBhAwJxwwDAG7hhAAMyoN8HZFccEIiwAYEIGxCIsAGBCBsQiLABgQgbEIiwAYEIGxCIsAGBCBsQiLABgQgbEIiwAYEIGxCIsAGBCBsQiLABgQgbEIiwAYEIGxCIsAGBCBsQSPMNAw7HquwdMBc2VMV0TwGwdsOAYE5Hn9HhQ5dsHC1H7P1fjkajDMiAdzCgpeezKw4IRNiAQIQNCETYgECWF8+QxTCM1ANL7y8AOcUWe65Sdy3VPQvgBoQNCETYgEAcYwMzyFxG8cqSCltsYAbpZRTDMLyypELYwGylk3Z/257cFd+1aVH6cevBnsyPtB7smc1j5+YK6OC9sHdtWpRZZuqf6bzT/zWV8e0+DsjmvbCn7zPdfNZm+XYfB0TyXtjqxo229i1wepk09cD9R1+wyosvsffCztoV184TLzPmwosvMavigEDe22Jnrm+nZP4zc80s8z9lfRyQzXthKyt9UjL8iV1xQCDCBgQibEAgTx5jOya15LZL9zTgRXrfJLMctt33DPDADQOAO2D73TUs0XzDAOXuC7WnttVDb71o14ClTz7vzwHNzmftGtCoe80TA3LDAAA2I2xAIMIGBCJsQCDCBgQibEAgwgYEImxAIMIGBCJsQCDCBgQibEAgwgYEImxAIMIGBCJsQCDCBgQibEAgwgYEImxAIMIGBCJsQCLTikgkYun5Xh9Q94sDD7Px+9C0/o2t/YYBHhgQuAOavw9z+mODARmQAbUMyDE2IBBhAwIRNiAQYQMCETYgEGF73uSUOnnpmu5ZwF0I2/M+u2LsOxHTPQu4C2HPiWEYhmFonICp1Me9aseaKo1zgAsR9pyYuk87/fTiYGFArZpfrHcacBvC9ra2SOyBhbonAfchbA+7GBu93D9eX80vqyAbYdvGuM6xr7gnEvtWU1WezmN8t/PtzzzCtlPq/Htnvlb/yOQnFwZb6iud+XJe1JMYe+Ht8/5sm7DtYRiGwwtp+07EN6yoKA4FnPyi3rKwsmBwdPLslRHdE9GAsG2QqtrJnfCJpHmgI76dd7mmZSjVUh9u74jrnogGhG0D59/0+uBM/4qaovnlIYe/ruc8vKryyIXBa+NJ3RNxGmHbxsmN9p5IHyelzEZZYeDexaXvn+7XPRGnEfacpEq++e+cOv7FUCDPaFhYkusvJMPWhvD+k3G/LaER9pykr0ST9Tin2o7HdqypzvVXEWP1gmJTqVO9/vo9GcL2mC8SY12x0W+sKNc9Ec8wlNrqvyU0wvaYPZHYo41VQc5KseKbqyqOXhwaGvPREhphe8ngaPLjcwNbG8K6J+IxJQWBdctKD51K6J6IcwjbS/afjK+vLS8t4KQUy7Y2VLV3+GgJzdr5UlyLX6OkqV79xPhho1ldpHsqHmQq9ddjalutWurZ1YmmpiYLz87pVcsZ0MYBD51K/K7tgo0D3o7UAfdG+15p77JxwGloH5Bdcc9oi/TtaOaklDv30MrKY13DAyOTuifiBML2hpOXhpNTZvPXSnVPxMOKQ3nra8sO+uMsNML2hrbjse2clDJnLfXhAx1x3dezcgJhe0Bv//jZqyMPrazQPRHPq51XVJSfF+0Z1j2RnCNsD3gnGmupD+cHOCllrgylWhrC+31wFhphu93wWPLw2f5HGzkpxR4bV1Sc6Bnul76ERthud6AzsW5ZWUVRUPdEhCjMz3uwtvy9TuFnoRG2qyWnzH3RGFdKsVdLQ/hAZ3xK9BIaYbvaR+cG51eEllYV6p6IKHdXF5YVBo93D+meSA4Rtqu1Rfoeb+ZdLvuJvxYaYbvXqcvXRsaT9y7hpBT7bVhR3tl7LT4sdgmNsN2rLRJ7bE0173HlQkEwb8OKindPid1oE7ZLXR2c6Lw0vGkVJ6XkSkt9+EBHIil0DY2wXWpvNLa5LhwK8gLlypKqguqS4DGhS2h837jR6MTUodOJbY28y5VbLQ3h9pMy98YJ243e7Uzcs7g0XMJJKbn1YG3FmSsjXw5N6J6I/QjbdaZM9U60bwfvcuVeKGg8tKri3U6BG23Cdp0j5weqSvJr7+KkFCdsrQ+/15mQt4JG2K7TFuF+AM5ZVFlQUx46E5f2riJhu8vnV0cS1ybvW1ameyI+0lIfPnpZ9yTsRtju0haJPdZU5eANeaHW15b3DplXBsd1T8ROhO0iseGJ491Dm+sqdU/EX/IDRnONcaBD1C9yEraL7DsRf3h1ZWE+L4rT1taYB08lJgWtoVm7YYBS6p/HXs7RVOzSFNymewp3YmJKvXpE/fgeVVGgeyq+9I+o8fUFZoOLVy0t3TBA4CkQ1m6YMJNoNOrMgPtOxJqXXNu4brFdA94xfw74nfsXt3fEv79pmV0D2j5DS89nr88VTKXeica2c1KKPvfdXdYdH+vtF7KERtiucPTiYElBYFUNd+XSJphnbFpdeUDK1RcI2xX2HOekFP221FUeOp2YSEpYQiNs/S7GRi8Pjj9wNyelaDa/PLS0uvC/5wd0T8QGhK1f2/HYtsaqQB5npei3tSG8X8QvchK2Zv0jk0cvDj5Sz0kprrBuaVnvwHhPYkz3ROaKsJ32frf66Nz/d/b2nYhtXFlRHAponBLSAnnG5tWVAi5gSthOM03VHf9qgzCRNNs7Eo81caUUF3mkPvzBmf7xSW8voRG20yoKjb7rl+x4/3RiVU3R/PKQ3ikh012l+SvmFWXuVXkRYTutPKT6hr8Ke0/khrteD0i/U5xXtNR7/o6chO20spCZ2mJ/1j2UHzAaFhYrpcYmp1472POHvV26ZwellLp3SWnf0ET6iEkp9fK+rquDXro0mhPnij+19rn04zc+fSn9kdTjrH+mH6c/K/00GcpCqm94UqU2183VSqnzfaN/bu9eWVP8i8ftOVEZcxTIM7bUVe4/Gd+5cYFSylTqRM9wcchLW8Gcz/Wptc+98elL6T9ZSadk/jP9OPVAWNVKqVBABfNUZ++1rtjog7XlbZG+37dd+O66eT/dvIhf2HSPLXWVh8/2j01OKaUGRiaDAaOkwEvvXOR8i525HZ79p9yyfzGqSvL//uHl9cvL//jvrqGx5G+eWD6vLF/3pKAuD4wPjyWXzytSSlWV5K9eUPzh5wObV1f29o8v8NoCp0O74ll73T6XH8g79+VId3x0R3P199bN45wzlxgcTb609+ITa+dtW1NlKNVSH37zk6ubV1deHhifX+GxsB3aFc/1V/GW1IlNP9++9Af311C1e6ysKfr1E7UHTydeae8enZi6Z3Fp/8jk+b7R3v7xBeUeu/yFKw7qsjbj6cNyqZv3n21b8pcf1TUuLNE9EWSrKQv96tu1BcG8X/7rXG//2Ja6cPvJeO/A+AK22FlSfab/qBvXvVN/Mo/DM/9WQnfdGxeVlHpqJcZXQkHj2U2LHm+ufuHt84X5ef85N3Chb5Rj7Fu43a74NIvh038ikGtb6iqXVRf+aX/X8FhyeCzJFhsQovauwt8+uTz12HPvRAq8mCFgl9KCwN9+0njkwqDuiVjmsZ9DgMMMQ93vwYvbiNpif7XwpgSutznM6tXmnWT49QZIll4UUWHDLlavYu38gJietTuBuPzK76mf5UNvvWjXgKVPPu/PAe3dYufiVTY7n7VtwLrXvDGglReFY2xAIMIGBCJsQCDCBgQibEAgwgYEImxAIMIGBCJsQCDCBgQibEAgwgYEImxAIMIGBCJsQCDCBgQibEAgwgYEImxAIMIGBCJsQCDCBgQSePlhzJ37Lz/sQ7m9YQCXkvcDXmXPM62IRCKWns+ADMiAWgbkGBsQiLABgQgbEIiwAYEIGxCIsAGBCBsQyI9hG4bh27OX/Ma3r7UfwwbEs3xKqQCmrSdCw818+1qzxQYE8t0WO33E5duf5f7h59fad1vs1CnyumcBJ/j5tfZd2IAfEDYgEGEDAhE2IJB/V8VTD3y7uALZfBc2JfuBYVi7Sqc8vgsbPuHnN7EVYUMkf8acicUzQCDCBgSyfCeQ3E0FwDQs3U3F74uHgEjsigMCETYgEGEDAhE2IBBhAwIRNiAQYQMCETYgEGEDAhE2IBBhAwIRNiAQYQMCETYg0P8Ay4KbWMD9pCMAAAAASUVORK5CYII="></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将arr[l, mid]和arr[mid+1, r]进行合并</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> _Merge(T* arr, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r) &#123;</span><br><span class="line"></span><br><span class="line">    T* aux = <span class="keyword">new</span> T[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        aux[i - l] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = l;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">            arr[k] = aux[j - l];</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; r) &#123;</span><br><span class="line">            arr[k] = aux[i - l];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i - l] &lt; aux[j - l]) &#123;</span><br><span class="line">            arr[k] = aux[i - l];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = aux[j - l];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] aux;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于arr[l, r]进行归并排序;l,r是闭区间</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> _MergeSort(T* arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    <span class="comment">// arr长度不大于15的时候使用插入排序</span></span><br><span class="line">    <span class="comment">// 可提升算法效率</span></span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">        <span class="built_in">InsertSort</span>(arr + l, r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (r + l) / <span class="number">2</span>;</span><br><span class="line">    _MergeSort(arr, l, mid);</span><br><span class="line">    _MergeSort(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">    _Merge1(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(T* arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    _MergeSort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习排序算法时的总结和记录&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://jesonwoo.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://jesonwoo.github.io/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="排序算法" scheme="https://jesonwoo.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Git仓库体积精简</title>
    <link href="https://jesonwoo.github.io/2021/12/06/Git%E4%BB%93%E5%BA%93%E4%BD%93%E7%A7%AF%E7%B2%BE%E7%AE%80/"/>
    <id>https://jesonwoo.github.io/2021/12/06/Git%E4%BB%93%E5%BA%93%E4%BD%93%E7%A7%AF%E7%B2%BE%E7%AE%80/</id>
    <published>2021-12-06T06:58:25.000Z</published>
    <updated>2021-12-11T08:31:11.011Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>本文将介绍如果工作上遇到了git新手向远程仓库提交大体积文件或者文件夹的处理方法</p><h3 id="精简仓库基本流程"><a href="#精简仓库基本流程" class="headerlink" title="精简仓库基本流程"></a>精简仓库基本流程</h3><ol><li>查找大文件</li><li>遍历提交记录并删除大文件对象</li><li>本地仓库回收空间</li><li>强制推送至远端</li><li>重新拉取仓库</li></ol><span id="more"></span><h3 id="查看本地仓库体积"><a href="#查看本地仓库体积" class="headerlink" title="查看本地仓库体积"></a>查看本地仓库体积</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git count-objects -vH</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong><br><img data-src="https://jesonblogbucket.oss-cn-shenzhen.aliyuncs.com/Git%E4%BB%93%E5%BA%93%E4%BD%93%E7%A7%AF%E7%B2%BE%E7%AE%80-%E5%9B%BE0.png"></p><h3 id="查找大文件"><a href="#查找大文件" class="headerlink" title="查找大文件"></a>查找大文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rev-list --all --objects | grep <span class="string">&quot;<span class="subst">$(git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -n 3 | awk -F &#x27; &#x27; &#x27;&#123;print $1&#125;&#x27;)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>效果如下：<br><img data-src="https://jesonblogbucket.oss-cn-shenzhen.aliyuncs.com/Git%E4%BB%93%E5%BA%93%E4%BD%93%E7%A7%AF%E7%B2%BE%E7%AE%80-%E5%9B%BE1.png"></p><ol><li><code>git rev-list --all --objects</code>: 按时间倒序遍历时候commit，并罗列出每次提交所有对象和对象ID</li><li><code>git verify-pack -v .git/objects/pack/*.idx</code>：这个命令是用来验证<code>git pack-objects</code>打包的Git归档文件并显示归档详情</li><li><code>git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -n 3 | awk -F &#39; &#39; &#39;&#123;print $1&#125;&#39;</code>: 遍历.git下面idx文件，查找历史大文件，并按照大小进行排序，列出最大的3个对象id</li></ol><p><strong>流程：</strong>每当<code>git rev-list --all --objects</code>输出一次结果时，先获取<code>&quot;$()&quot;</code>的结果 ，最后通过<code>grep</code>来匹配</p><p><strong>弊端：</strong> 当对象数量较多时，此命令效率会很低</p><p><strong>如果耗时过长可分步骤来查找大文件，步骤如下：</strong></p><ol><li><code>git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -n 3</code>: 查找历史大文件，并按照大小进行排序，列出最大的3个对象id</li></ol><p><strong>效果如下：</strong><br><img data-src="https://jesonblogbucket.oss-cn-shenzhen.aliyuncs.com/Git%E4%BB%93%E5%BA%93%E4%BD%93%E7%A7%AF%E7%B2%BE%E7%AE%80-%E5%9B%BE6.png"><br>2. <code>git rev-list --objects --all | grep 60ecdaf1da26086feb8e6cb56f9843f6cf2029b6</code>: 查看指定对象id的对象信息<br><strong>效果如下：</strong><br><img data-src="https://jesonblogbucket.oss-cn-shenzhen.aliyuncs.com/Git%E4%BB%93%E5%BA%93%E4%BD%93%E7%A7%AF%E7%B2%BE%E7%AE%80-%E5%9B%BE5.png"></p><h3 id="遍历提交记录并删除大文件对象"><a href="#遍历提交记录并删除大文件对象" class="headerlink" title="遍历提交记录并删除大文件对象"></a>遍历提交记录并删除大文件对象</h3><p><strong>注意：</strong>  本地仓库不能有修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch --force --index-filter <span class="string">&#x27;git rm -rf --cached --ignore-unmatch 大文件路径&#x27;</span> --prune-empty --tag-name-filter cat -- --all</span><br></pre></td></tr></table></figure><p>例如：<code>git filter-branch --force --index-filter &#39;git rm -rf --cached --ignore-unmatch env/automake-1.15.tar &#39; --prune-empty --tag-name-filter cat -- --all</code><br><strong>效果如下：</strong><br><img data-src="https://jesonblogbucket.oss-cn-shenzhen.aliyuncs.com/Git%E4%BB%93%E5%BA%93%E4%BD%93%E7%A7%AF%E7%B2%BE%E7%AE%80-%E5%9B%BE2.png"></p><h3 id="本地仓库回收空间"><a href="#本地仓库回收空间" class="headerlink" title="本地仓库回收空间"></a>本地仓库回收空间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -rf .git/refs/original/              <span class="comment"># 删除本地仓库引用</span></span><br><span class="line">git reflog expire --expire=now --all    <span class="comment"># 设置所有reflog条目现在过期</span></span><br><span class="line">git gc --aggressive --prune=now         <span class="comment"># 回收空间，移除无效或异常的文件</span></span><br></pre></td></tr></table></figure><p><strong>回收完成之后再次执行<code>git count-objects -vH</code></strong></p><p><strong>结果如下：</strong><br><img data-src="https://jesonblogbucket.oss-cn-shenzhen.aliyuncs.com/Git%E4%BB%93%E5%BA%93%E4%BD%93%E7%A7%AF%E7%B2%BE%E7%AE%80-%E5%9B%BE4.png"></p><h3 id="强制推送至远端"><a href="#强制推送至远端" class="headerlink" title="强制推送至远端"></a>强制推送至远端</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --force --all</span><br></pre></td></tr></table></figure><h3 id="重新拉取仓库"><a href="#重新拉取仓库" class="headerlink" title="重新拉取仓库"></a>重新拉取仓库</h3><p>​    <strong>不能在原先的本地仓库拉取代码，不然会进行合并，导致本地仓库更大</strong></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://blog.csdn.net/wchy1128/article/details/89493389">Git 瘦身代码库，永久删除大文件</a></li><li><a href="https://www.cnblogs.com/geoffreyone/p/14603537.html#">Git项目过大清理（针对大文件）</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;本文将介绍如果工作上遇到了git新手向远程仓库提交大体积文件或者文件夹的处理方法&lt;/p&gt;
&lt;h3 id=&quot;精简仓库基本流程&quot;&gt;&lt;a href=&quot;#精简仓库基本流程&quot; class=&quot;headerlink&quot; title=&quot;精简仓库基本流程&quot;&gt;&lt;/a&gt;精简仓库基本流程&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;查找大文件&lt;/li&gt;
&lt;li&gt;遍历提交记录并删除大文件对象&lt;/li&gt;
&lt;li&gt;本地仓库回收空间&lt;/li&gt;
&lt;li&gt;强制推送至远端&lt;/li&gt;
&lt;li&gt;重新拉取仓库&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Git" scheme="https://jesonwoo.github.io/categories/Git/"/>
    
    
    <category term="Git" scheme="https://jesonwoo.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>leetcode练习记录-字符串</title>
    <link href="https://jesonwoo.github.io/2021/12/03/leetcode%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://jesonwoo.github.io/2021/12/03/leetcode%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-12-03T07:46:58.079Z</published>
    <updated>2021-12-11T08:28:40.551Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode字符串算法练习，不定期更新</p><span id="more"></span><h2 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p></blockquote><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;anagram&quot;</span>, <span class="attr">t</span> = <span class="string">&quot;nagaram&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;rat&quot;</span>, <span class="attr">t</span> = <span class="string">&quot;car&quot;</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>说明：</strong><br>你可以假设字符串只包含小写字母。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>字母异位词的字符串长度和相对应的字母数量是相等的，因此可以借鉴桶排序的思想来统计每个字母的数量是否是相等的，如果不相等则就不是字母异位词</p></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sArr[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> tArr[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        sArr[s[i]]++;</span><br><span class="line">        tArr[t[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sArr[i] != tArr[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证回文字符串"><a href="#验证回文字符串" class="headerlink" title="验证回文字符串"></a>验证回文字符串</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p></blockquote><p><strong>说明：</strong> 本题中，我们将空字符串定义为有效的回文串。<br><strong>示例 1:</strong></p> <figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="comment">&quot;A man, a plan, a canal: Panama&quot;</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p> <figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="comment">&quot;race a car&quot;</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><blockquote><p>使用两个游标，一个在字符串头，一个在字符串尾，两个游标同时向中间靠拢，遇到<strong>非字母和数字</strong>就跳过</p></blockquote><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLetterOrNum</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) </span><br><span class="line">        || (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">        || (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareLetter</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">char</span> c1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == c1) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> c + <span class="number">32</span> == c1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="number">32</span> == c1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>() || s.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;               <span class="comment">// 字符串第一个字符</span></span><br><span class="line">    <span class="keyword">int</span> r = s.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 字符串最后一个字符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">// 从前往后找到字母或数字, 保证l不越界</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; s.<span class="built_in">size</span>() &amp;&amp; !<span class="built_in">isLetterOrNum</span>(s[l])) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从后往前找到字母或数字， 保证r不越界</span></span><br><span class="line">        <span class="keyword">while</span>(r &gt;= <span class="number">0</span> &amp;&amp; !<span class="built_in">isLetterOrNum</span>(s[r])) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果字符串没有字母或数字则返回真</span></span><br><span class="line">        <span class="keyword">if</span> (l == s.<span class="built_in">size</span>() || r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">compareLetter</span>(s[l], s[r]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++l;</span><br><span class="line">        --r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串转换整数-atoi"><a href="#字符串转换整数-atoi" class="headerlink" title="字符串转换整数(atoi)"></a>字符串转换整数(atoi)</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><blockquote><p>请你来实现一个 <code>atoi</code> 函数，使其能将字符串转换成整数.首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。<br><strong>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</strong>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p></blockquote><p><strong>说明：</strong> 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><blockquote><p>根据题干分为几个步骤</p><ol><li>跳开字符串前面的空格</li><li>判断正负号</li><li>判断是否是数字，如果是就计算数值</li><li>判断该数字是否溢出，因此需要4个字节以上的存储空间，这里选用double类型（在leetcode的环境中，long或者long long存储num都会溢出）</li></ol></blockquote><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> negative = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 忽略前面的空格</span></span><br><span class="line">    <span class="keyword">while</span> (str[i] == <span class="string">&#x27; &#x27;</span>)++i;</span><br><span class="line">    <span class="comment">// 判断正负号</span></span><br><span class="line">    <span class="keyword">if</span> (str[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        negative = <span class="number">-1</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算数字</span></span><br><span class="line">    <span class="keyword">while</span> (str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        num = str[i] - <span class="string">&#x27;0&#x27;</span> + num * <span class="number">10</span>;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 恢复数字的符号</span></span><br><span class="line">    num *= negative;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num &lt; INT_MIN) &#123;</span><br><span class="line">        num = INT_MIN;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; INT_MAX) &#123;</span><br><span class="line">        num = INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现strStr"><a href="#实现strStr" class="headerlink" title="实现strStr()"></a>实现strStr()</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><blockquote><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  <strong>-1</strong>。</p></blockquote><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">haystack</span> = <span class="string">&quot;hello&quot;</span>, <span class="attr">needle</span> = <span class="string">&quot;ll&quot;</span></span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">haystack</span> = <span class="string">&quot;aaaaa&quot;</span>, <span class="attr">needle</span> = <span class="string">&quot;bba&quot;</span></span><br><span class="line">输出: -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。<br>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与C语言的 <code>strstr()</code>以及 Java的 <code>indexOf()</code> 定义相符。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><blockquote><p>在haystack字符串中找出needle字符串意味着<strong>haystack的字符长度大于等于needle的字符长度</strong>，而且只需要执行haystack.length()-needle.length()次比较</p></blockquote><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">return</span> haystack.<span class="built_in">find</span>(needle);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> hlen = haystack.<span class="built_in">length</span>(), nlen = needle.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= hlen - nlen; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nlen; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i + j] != needle[j]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == nlen) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><blockquote><p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p></blockquote><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="string">&quot;flower&quot;</span>,<span class="string">&quot;flow&quot;</span>,<span class="string">&quot;flight&quot;</span>]</span><br><span class="line">输出: <span class="string">&quot;fl&quot;</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;racecar&quot;</span>,<span class="string">&quot;car&quot;</span>]</span><br><span class="line">输出: <span class="string">&quot;&quot;</span></span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 所有输入只包含小写字母 <code>a-z</code> 。</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><blockquote><p>以数组中的第一个字符串作为基准，遍历比较字符串相应下标的字符，相等则放入vector中，如果其中一个不相等则直接返回</p></blockquote><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(strs.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;strs[<span class="number">0</span>].<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;strs.<span class="built_in">size</span>(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(strs[j][i]!=strs[<span class="number">0</span>][i])</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(strs[<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;leetcode字符串算法练习，不定期更新&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://jesonwoo.github.io/categories/leetcode/"/>
    
    
    <category term="算法练习" scheme="https://jesonwoo.github.io/tags/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    <category term="leetcode" scheme="https://jesonwoo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>插入排序(InsertionSort)</title>
    <link href="https://jesonwoo.github.io/2021/12/03/%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>https://jesonwoo.github.io/2021/12/03/%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2021-12-03T01:59:06.615Z</published>
    <updated>2021-12-11T08:28:25.406Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-算法概述"><a href="#1-算法概述" class="headerlink" title="1.算法概述"></a>1.算法概述</h3><p>​    插入排序是一个平均时间复杂度**O(n^2)**级别的排序算法，它具有稳定性，即排序完成之后各个相同元素的相对顺序保持一致。</p><p>​    插入排序的基本思想：<strong>在一个有序的序列中寻找一个合适的位置进行插入</strong></p><span id="more"></span><h3 id="2-算法步骤"><a href="#2-算法步骤" class="headerlink" title="2.算法步骤"></a>2.算法步骤</h3><ol><li>默认取第二个元素开始与已经排好序的元素序列比较，因为第一个元素已经是有序的</li><li>取下一个元素如果元素大于当前待插入的元素（动图中红色色块）则移动至下一个位置</li><li>重复步骤2，直至找到当前待插入的元素<strong>小于或者等于</strong>比较的元素</li><li>将当前待插入的元素插入到新的位置</li><li>重复步骤2~4</li></ol><h3 id="3-算法动图演示"><a href="#3-算法动图演示" class="headerlink" title="3.算法动图演示"></a>3.算法动图演示</h3><p><img data-src="https://jesonblogbucket.oss-cn-shenzhen.aliyuncs.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8A%A8%E6%95%88.gif" alt="插入排序动效"></p><h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(T* arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        T tmp = arr[i];</span><br><span class="line">        <span class="comment">// 向前查找一个合适的插入位置</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; tmp; --j) &#123;</span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-插入排序总结"><a href="#5-插入排序总结" class="headerlink" title="5.插入排序总结"></a>5.插入排序总结</h3><p>​    插入排序的平均复杂度虽然是O(n^2)，但是插入排序在小规模数据的中排序效率的表现甚至O(nlogn)级别的排序效率高，因此常常被用来作为大规模排序中的子排序，以提高算法运行效率</p>]]></content>
    
    
    <summary type="html">插入排序的优化与总结</summary>
    
    
    
    <category term="算法" scheme="https://jesonwoo.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://jesonwoo.github.io/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="排序算法" scheme="https://jesonwoo.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
