<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git仓库体积精简</title>
    <url>/2021/12/06/Git%E4%BB%93%E5%BA%93%E4%BD%93%E7%A7%AF%E7%B2%BE%E7%AE%80/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>本文将介绍如果工作上遇到了git新手向远程仓库提交大体积文件或者文件夹的处理方法</p>
<h3 id="精简仓库基本流程"><a href="#精简仓库基本流程" class="headerlink" title="精简仓库基本流程"></a>精简仓库基本流程</h3><ol>
<li>查找大文件</li>
<li>遍历提交记录并删除大文件对象</li>
<li>本地仓库回收空间</li>
<li>强制推送至远端</li>
<li>重新拉取仓库</li>
</ol>
<span id="more"></span>

<h3 id="查看本地仓库体积"><a href="#查看本地仓库体积" class="headerlink" title="查看本地仓库体积"></a>查看本地仓库体积</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git count-objects -vH</span><br></pre></td></tr></table></figure>
<p><strong>效果如下：</strong><br><img data-src="https://jesonblogbucket.oss-cn-shenzhen.aliyuncs.com/Git%E4%BB%93%E5%BA%93%E4%BD%93%E7%A7%AF%E7%B2%BE%E7%AE%80-%E5%9B%BE0.png"></p>
<h3 id="查找大文件"><a href="#查找大文件" class="headerlink" title="查找大文件"></a>查找大文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rev-list --all --objects | grep <span class="string">&quot;<span class="subst">$(git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -n 3 | awk -F &#x27; &#x27; &#x27;&#123;print $1&#125;&#x27;)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>效果如下：<br><img data-src="https://jesonblogbucket.oss-cn-shenzhen.aliyuncs.com/Git%E4%BB%93%E5%BA%93%E4%BD%93%E7%A7%AF%E7%B2%BE%E7%AE%80-%E5%9B%BE1.png"></p>
<ol>
<li><code>git rev-list --all --objects</code>: 按时间倒序遍历时候commit，并罗列出每次提交所有对象和对象ID</li>
<li><code>git verify-pack -v .git/objects/pack/*.idx</code>：这个命令是用来验证<code>git pack-objects</code>打包的Git归档文件并显示归档详情</li>
<li><code>git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -n 3 | awk -F &#39; &#39; &#39;&#123;print $1&#125;&#39;</code>: 遍历.git下面idx文件，查找历史大文件，并按照大小进行排序，列出最大的3个对象id</li>
</ol>
<p><strong>流程：</strong>每当<code>git rev-list --all --objects</code>输出一次结果时，先获取<code>&quot;$()&quot;</code>的结果 ，最后通过<code>grep</code>来匹配</p>
<p><strong>弊端：</strong> 当对象数量较多时，此命令效率会很低</p>
<p><strong>如果耗时过长可分步骤来查找大文件，步骤如下：</strong></p>
<ol>
<li><code>git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -n 3</code>: 查找历史大文件，并按照大小进行排序，列出最大的3个对象id</li>
</ol>
<p><strong>效果如下：</strong><br><img data-src="https://jesonblogbucket.oss-cn-shenzhen.aliyuncs.com/Git%E4%BB%93%E5%BA%93%E4%BD%93%E7%A7%AF%E7%B2%BE%E7%AE%80-%E5%9B%BE6.png"><br>2. <code>git rev-list --objects --all | grep 60ecdaf1da26086feb8e6cb56f9843f6cf2029b6</code>: 查看指定对象id的对象信息<br><strong>效果如下：</strong><br><img data-src="https://jesonblogbucket.oss-cn-shenzhen.aliyuncs.com/Git%E4%BB%93%E5%BA%93%E4%BD%93%E7%A7%AF%E7%B2%BE%E7%AE%80-%E5%9B%BE5.png"></p>
<h3 id="遍历提交记录并删除大文件对象"><a href="#遍历提交记录并删除大文件对象" class="headerlink" title="遍历提交记录并删除大文件对象"></a>遍历提交记录并删除大文件对象</h3><p><strong>注意：</strong>  本地仓库不能有修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git filter-branch --force --index-filter <span class="string">&#x27;git rm -rf --cached --ignore-unmatch 大文件路径&#x27;</span> --prune-empty --tag-name-filter cat -- --all</span><br></pre></td></tr></table></figure>
<p>例如：<code>git filter-branch --force --index-filter &#39;git rm -rf --cached --ignore-unmatch env/automake-1.15.tar &#39; --prune-empty --tag-name-filter cat -- --all</code><br><strong>效果如下：</strong><br><img data-src="https://jesonblogbucket.oss-cn-shenzhen.aliyuncs.com/Git%E4%BB%93%E5%BA%93%E4%BD%93%E7%A7%AF%E7%B2%BE%E7%AE%80-%E5%9B%BE2.png"></p>
<h3 id="本地仓库回收空间"><a href="#本地仓库回收空间" class="headerlink" title="本地仓库回收空间"></a>本地仓库回收空间</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -rf .git/refs/original/              <span class="comment"># 删除本地仓库引用</span></span><br><span class="line">git reflog expire --expire=now --all    <span class="comment"># 设置所有reflog条目现在过期</span></span><br><span class="line">git gc --aggressive --prune=now         <span class="comment"># 回收空间，移除无效或异常的文件</span></span><br></pre></td></tr></table></figure>
<p><strong>回收完成之后再次执行<code>git count-objects -vH</code></strong></p>
<p><strong>结果如下：</strong><br><img data-src="https://jesonblogbucket.oss-cn-shenzhen.aliyuncs.com/Git%E4%BB%93%E5%BA%93%E4%BD%93%E7%A7%AF%E7%B2%BE%E7%AE%80-%E5%9B%BE4.png"></p>
<h3 id="强制推送至远端"><a href="#强制推送至远端" class="headerlink" title="强制推送至远端"></a>强制推送至远端</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin --force --all</span><br></pre></td></tr></table></figure>

<h3 id="重新拉取仓库"><a href="#重新拉取仓库" class="headerlink" title="重新拉取仓库"></a>重新拉取仓库</h3><p>​    <strong>不能在原先的本地仓库拉取代码，不然会进行合并，导致本地仓库更大</strong></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://blog.csdn.net/wchy1128/article/details/89493389">Git 瘦身代码库，永久删除大文件</a></li>
<li><a href="https://www.cnblogs.com/geoffreyone/p/14603537.html#">Git项目过大清理（针对大文件）</a></li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode练习记录-字符串</title>
    <url>/2021/12/03/leetcode%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>leetcode字符串算法练习，不定期更新</p>
<span id="more"></span>
<h2 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p>
</blockquote>
<p><strong>示例 1:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;anagram&quot;</span>, <span class="attr">t</span> = <span class="string">&quot;nagaram&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;rat&quot;</span>, <span class="attr">t</span> = <span class="string">&quot;car&quot;</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong><br>你可以假设字符串只包含小写字母。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>字母异位词的字符串长度和相对应的字母数量是相等的，因此可以借鉴桶排序的思想来统计每个字母的数量是否是相等的，如果不相等则就不是字母异位词</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sArr[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> tArr[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        sArr[s[i]]++;</span><br><span class="line">        tArr[t[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sArr[i] != tArr[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="验证回文字符串"><a href="#验证回文字符串" class="headerlink" title="验证回文字符串"></a>验证回文字符串</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
</blockquote>
<p><strong>说明：</strong> 本题中，我们将空字符串定义为有效的回文串。<br><strong>示例 1:</strong></p>
 <figure class="highlight smalltalk"><table><tr><td class="code"><pre><span class="line">输入: <span class="comment">&quot;A man, a plan, a canal: Panama&quot;</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
 <figure class="highlight smalltalk"><table><tr><td class="code"><pre><span class="line">输入: <span class="comment">&quot;race a car&quot;</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>使用两个游标，一个在字符串头，一个在字符串尾，两个游标同时向中间靠拢，遇到<strong>非字母和数字</strong>就跳过</p>
</blockquote>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLetterOrNum</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) </span><br><span class="line">        || (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">        || (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareLetter</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">char</span> c1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == c1) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> c + <span class="number">32</span> == c1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="number">32</span> == c1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>() || s.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;               <span class="comment">// 字符串第一个字符</span></span><br><span class="line">    <span class="keyword">int</span> r = s.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 字符串最后一个字符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">// 从前往后找到字母或数字, 保证l不越界</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; s.<span class="built_in">size</span>() &amp;&amp; !<span class="built_in">isLetterOrNum</span>(s[l])) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从后往前找到字母或数字， 保证r不越界</span></span><br><span class="line">        <span class="keyword">while</span>(r &gt;= <span class="number">0</span> &amp;&amp; !<span class="built_in">isLetterOrNum</span>(s[r])) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果字符串没有字母或数字则返回真</span></span><br><span class="line">        <span class="keyword">if</span> (l == s.<span class="built_in">size</span>() || r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">compareLetter</span>(s[l], s[r]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++l;</span><br><span class="line">        --r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串转换整数-atoi"><a href="#字符串转换整数-atoi" class="headerlink" title="字符串转换整数(atoi)"></a>字符串转换整数(atoi)</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>请你来实现一个 <code>atoi</code> 函数，使其能将字符串转换成整数.首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。<br><strong>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</strong>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
</blockquote>
<p><strong>说明：</strong> 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>根据题干分为几个步骤</p>
<ol>
<li>跳开字符串前面的空格</li>
<li>判断正负号</li>
<li>判断是否是数字，如果是就计算数值</li>
<li>判断该数字是否溢出，因此需要4个字节以上的存储空间，这里选用double类型（在leetcode的环境中，long或者long long存储num都会溢出）</li>
</ol>
</blockquote>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> negative = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 忽略前面的空格</span></span><br><span class="line">    <span class="keyword">while</span> (str[i] == <span class="string">&#x27; &#x27;</span>)++i;</span><br><span class="line">    <span class="comment">// 判断正负号</span></span><br><span class="line">    <span class="keyword">if</span> (str[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        negative = <span class="number">-1</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算数字</span></span><br><span class="line">    <span class="keyword">while</span> (str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        num = str[i] - <span class="string">&#x27;0&#x27;</span> + num * <span class="number">10</span>;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 恢复数字的符号</span></span><br><span class="line">    num *= negative;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num &lt; INT_MIN) &#123;</span><br><span class="line">        num = INT_MIN;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; INT_MAX) &#123;</span><br><span class="line">        num = INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现strStr"><a href="#实现strStr" class="headerlink" title="实现strStr()"></a>实现strStr()</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  <strong>-1</strong>。</p>
</blockquote>
<p><strong>示例 1:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">haystack</span> = <span class="string">&quot;hello&quot;</span>, <span class="attr">needle</span> = <span class="string">&quot;ll&quot;</span></span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">haystack</span> = <span class="string">&quot;aaaaa&quot;</span>, <span class="attr">needle</span> = <span class="string">&quot;bba&quot;</span></span><br><span class="line">输出: -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong> 当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。<br>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与C语言的 <code>strstr()</code>以及 Java的 <code>indexOf()</code> 定义相符。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>在haystack字符串中找出needle字符串意味着<strong>haystack的字符长度大于等于needle的字符长度</strong>，而且只需要执行haystack.length()-needle.length()次比较</p>
</blockquote>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">return</span> haystack.<span class="built_in">find</span>(needle);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> hlen = haystack.<span class="built_in">length</span>(), nlen = needle.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= hlen - nlen; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nlen; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i + j] != needle[j]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == nlen) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><blockquote>
<p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
</blockquote>
<p><strong>示例 1:</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">&quot;flower&quot;</span>,<span class="string">&quot;flow&quot;</span>,<span class="string">&quot;flight&quot;</span>]</span><br><span class="line">输出: <span class="string">&quot;fl&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;racecar&quot;</span>,<span class="string">&quot;car&quot;</span>]</span><br><span class="line">输出: <span class="string">&quot;&quot;</span></span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong> 所有输入只包含小写字母 <code>a-z</code> 。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>以数组中的第一个字符串作为基准，遍历比较字符串相应下标的字符，相等则放入vector中，如果其中一个不相等则直接返回</p>
</blockquote>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(strs.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;strs[<span class="number">0</span>].<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;strs.<span class="built_in">size</span>(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(strs[j][i]!=strs[<span class="number">0</span>][i])</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(strs[<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>算法练习</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序(InsertionSort)</title>
    <url>/2021/12/03/%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="1-算法概述"><a href="#1-算法概述" class="headerlink" title="1.算法概述"></a>1.算法概述</h3><p>​    插入排序是一个平均时间复杂度**O(n^2)**级别的排序算法，它具有稳定性，即排序完成之后各个相同元素的相对顺序保持一致。</p>
<p>​    插入排序的基本思想：<strong>在一个有序的序列中寻找一个合适的位置进行插入</strong></p>
<span id="more"></span>
<h3 id="2-算法步骤"><a href="#2-算法步骤" class="headerlink" title="2.算法步骤"></a>2.算法步骤</h3><ol>
<li>默认取第二个元素开始与已经排好序的元素序列比较，因为第一个元素已经是有序的</li>
<li>取下一个元素如果元素大于当前待插入的元素（动图中红色色块）则移动至下一个位置</li>
<li>重复步骤2，直至找到当前待插入的元素<strong>小于或者等于</strong>比较的元素</li>
<li>将当前待插入的元素插入到新的位置</li>
<li>重复步骤2~4</li>
</ol>
<h3 id="3-算法动图演示"><a href="#3-算法动图演示" class="headerlink" title="3.算法动图演示"></a>3.算法动图演示</h3><p><img data-src="https://jesonblogbucket.oss-cn-shenzhen.aliyuncs.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8A%A8%E6%95%88.gif" alt="插入排序动效"></p>
<h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(T* arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        T tmp = arr[i];</span><br><span class="line">        <span class="comment">// 向前查找一个合适的插入位置</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; tmp; --j) &#123;</span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-插入排序总结"><a href="#5-插入排序总结" class="headerlink" title="5.插入排序总结"></a>5.插入排序总结</h3><p>​    插入排序的平均复杂度虽然是O(n^2)，但是插入排序在小规模数据的中排序效率的表现甚至O(nlogn)级别的排序效率高，因此常常被用来作为大规模排序中的子排序，以提高算法运行效率</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>常用排序算法总结</title>
    <url>/2021/12/21/%E7%AE%97%E6%B3%95-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>学习排序算法时的总结和记录</p>
<span id="more"></span>

<h2 id="各种排序算法比较"><a href="#各种排序算法比较" class="headerlink" title="各种排序算法比较"></a>各种排序算法比较</h2><table>
<thead>
<tr>
<th>排序</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>直接插入排序</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>根据增量序列的不同时间复杂度不同；可以很接近<strong>O(nlogn)</strong></td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>期望值O(nlogn),需要考虑数组几乎有序和存在大量重复元素的情况</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>不稳定</td>
</tr>
</tbody></table>
<h2 id="直接插入排序（InsertSort）"><a href="#直接插入排序（InsertSort）" class="headerlink" title="直接插入排序（InsertSort）"></a>直接插入排序（InsertSort）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(T* arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[idx]) &#123;</span><br><span class="line">                idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[idx]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序（ShellSort）"><a href="#希尔排序（ShellSort）" class="headerlink" title="希尔排序（ShellSort）"></a>希尔排序（ShellSort）</h2><h3 id="普通希尔排序"><a href="#普通希尔排序" class="headerlink" title="普通希尔排序"></a>普通希尔排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(T* arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            T tmp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; tmp; j -= gap) &#123;</span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化希尔排序（调整increment-sequence）"><a href="#优化希尔排序（调整increment-sequence）" class="headerlink" title="优化希尔排序（调整increment sequence）"></a>优化希尔排序（调整increment sequence）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; n / <span class="number">3</span>)</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// h-sort the array</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序</span></span><br><span class="line">            T e = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= h &amp;&amp; e &lt; arr[j - h]; j -= h)</span><br><span class="line">                arr[j] = arr[j - h];</span><br><span class="line">            arr[j] = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="冒泡排序（BubbleSot）"><a href="#冒泡排序（BubbleSot）" class="headerlink" title="冒泡排序（BubbleSot）"></a>冒泡排序（BubbleSot）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSot</span><span class="params">(T* arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序的优化"><a href="#冒泡排序的优化" class="headerlink" title="冒泡排序的优化"></a>冒泡排序的优化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// * 用一个变量flag记录下最后一个发生交换的位置，后面没有发生交换的已经有序 </span></span><br><span class="line"><span class="comment">// * 所以可以用这个值来作为下一次比较结束的位置 </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSot</span><span class="params">(T *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = n;</span><br><span class="line">    <span class="keyword">int</span> j, k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flag; i++) &#123;</span><br><span class="line">        k = flag; <span class="comment">//保存最后一次交换的位置下标</span></span><br><span class="line">        flag = <span class="number">0</span>; <span class="comment">//如果flag值不变则说明之后的数据有序，因此可退出程序</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                flag = j;</span><br><span class="line">                <span class="built_in">swap</span>(arr[j], arr[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="快速排序（QuickSort）"><a href="#快速排序（QuickSort）" class="headerlink" title="快速排序（QuickSort）"></a>快速排序（QuickSort）</h2><h3 id="普通快排"><a href="#普通快排" class="headerlink" title="普通快排"></a>普通快排</h3><p>​    快排核心步骤就是partition操作，partition操作一般情况下就是以arr[l]元素（记为tmp）为基准将arr分为大于tmp和小于tmp两部分 ， 最终将其分为 arr[l … j] &lt; tmp和arr[j+1 … r] &gt; tmp两部分</p>
<p><img data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARkAAACBCAIAAAB7MFnaAAAAA3NCSVQICAjb4U/gAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAFIklEQVR4nO3dy3HbMBSFYTGTCrJ0C3ID2bgbV+VU47RAteDs0gKz4ISDAQkIIA4I8PL/VnpQN5DCYzxIUcM0TTcAxb61bgBgBFkCNMgSoEGWAA2yBGiQJUCDLAEaZAnQIEuABlkCNMgSoEGWAA2yBGiQJUDje+4LHo9HjXYY8/r62roJRxjHsXUT6rrf7xlbTznGccza/rKldny256J9gx3+D+4oxRgP0CBLbQzD8PSRw4p7zy53hU26guz5EiSmaRqGYfo/WHJvu7xtQqUqNRJZyNKhQj2Ad3tyJiRLnNaZCSUQTZClQ7m7fkq/tDZHzuvW4ht7t0Ov2uz3nr4KC7J0tHgG1s9u3n0apHmDdVZDPWFoMEmE0pGlo0W6lKcxC91dZyal49rRKyKCLB1n3SdEHpnDsNz2brAm0SGydJzcnXs9KqtnDmdoMZ1YpiBLDUTi8XQWFCniDdXiR428bs1dKmS+tA9ZaiM0X0p81eYYL7JosTkjcpcEM5qOAM57sC80fnMX+lCOfqmNfV1BfIxXiONLhchSGzXGeJvSV8k5vlSIMd6JMc/pCv1SG4kxWKY6m+sKT7sa79n19hylFSJLbaSM8bzh2XoD91WJZ74updJPj0AislRRpPMJPRU5USjr34pkb7195PtODCPT5f1N4mIPibjegw1c74FSlGpQinU8QIMsARpkCdAgS4AGWQI0yBKgQZYADbIEaJAlQIMsARpkCdAgS4AGWQI0yBKgQZYADbIEaJAlQCP7uhm/fv+p1JQSP3/8bd0EGJT1HXUj107J+15+2OPxoBSlllJZ2zPGAzTIEqBBlgANsgRoGFl7iOBXT3AM+/3SfB3A1q2AffazBByDLAEadedL728vy+2Pzy/3kY/Pr5TbVZuHS3FnzjVm0RWz9P724oZhvrskanl2Tk7ocUBljs0wDMtPTml/EadiluKRWGLmdT6hxwGVpS/SLkpVH+MtkaCfgW0V1x68MR5gG+t4gEbd+ZI3rnPvuksO7lPe4+W8n17luO1l1d4T6s6X0iNRbzRIeDCrvScwxgM0Tn9u6zwmfG/dDJiU1ZXRLwEaeddO6fB7+cJ5JKUoVVKKfgnQIEuABlkCNMgSoHH6NfEU7qn1hRNTVan12f6qap28QUmp5csRm5V3Ny9UtpD9LHkfXMnnKCx10x2G7/MNFpaKfLPI/fZRbvO0X1jyMMZDj0JXvHHz4349trCshP0sCXsSpLvgx25/jDeTHMWT7x+qVpUMe7xSbts6eYNncZUsSXY1LVUAbs5op593N+vwY6/H/hjPtWOEvUmy95eM+zfbo3p3N/XeL2xYz66VJYne/soWTsfjBZHOfpa0fxFV+1m3f6fNv8F67GfJVbijrI+ZKBrVUT/Q/xt0O95+PreZ/bUH7UU6VbuXsFXeuE54skKJwjcYuTZDyUJL1Us+2M/STfeRaT967eS+qzrl1eKv3V25aj92rTEeUI+Rfkk406UUpfbJzlLuD7UfUwpob8oxjmPW9pSi1HVKMV8CNMgSoEGWAA2yBGhcKEvzjyv2UAQmXShLQFVGjtWmmBTnj0iKwCT6JUDjKv2S5KRs4fnmsOcq/dJ8ZLqHIrDqKlkCaiNLgAZZAjTIEqBxlXU8iapXC8DZ2c+S9iI4kjowyX6WbhwXwiGyf0e9XlOA3tzv9/SN+7paH3BerOMBGmQJ0CBLgAZZAjTIEqBBlgANsgRokCVAgywBGmQJ0CBLgAZZAjTIEqBBlgCNfzoo093eocOXAAAAAElFTkSuQmCC" alt="partition"></p>
<h4 id="各个变量定义"><a href="#各个变量定义" class="headerlink" title="各个变量定义"></a>各个变量定义</h4><ul>
<li><p>l：arr左边界</p>
</li>
<li><p>r：arr有边界</p>
</li>
<li><p>i：准备进行判断比较的位置</p>
</li>
<li><p>j：<code>arr[l ... j] &lt; tmp</code>，一开始 <code>j == l</code> 时表示没有元素小于tmp</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> _Partition(T* arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = l;</span><br><span class="line">    T tmp = arr[l];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; tmp) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[j + <span class="number">1</span>], arr[i]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[j], arr[l]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="普通快排的缺陷"><a href="#普通快排的缺陷" class="headerlink" title="普通快排的缺陷"></a>普通快排的缺陷</h4><ul>
<li>当数组近乎有序的时候,算法会退化成O(n^2)级别的算法</li>
</ul>
<p>​    采用随机选择一个标定元素，则该排序的期望值为O(nlogn)，大概率上避免退化成O(n^2)；在partition一开始的位置<code> swap(arr[l], arr[(rand() % (r - l + 1)) + l]);</code></p>
<ul>
<li>当存在大量重复元素的时候,算法也会退化成O(n^2)<h4 id="普通快排的优化"><a href="#普通快排的优化" class="headerlink" title="普通快排的优化"></a>普通快排的优化</h4>​</li>
<li>将整个数组通过标定元素比较分成三个部分，小于标定，等于标定，大于标定因此如果存在大量重复元素也能高效执行算</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> _QuickSort3(T* arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    <span class="comment">// 当元素少于16个时，使用插入排序作为快速排序的自排序更为高效</span></span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="built_in">InsertSort</span>(arr + l, r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(arr[l], arr[(<span class="built_in">rand</span>() % (r - l + <span class="number">1</span>)) + l]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = arr[l];</span><br><span class="line">    <span class="keyword">int</span> lt  = l;     <span class="comment">// arr[l...lt] &lt; tmp</span></span><br><span class="line">    <span class="keyword">int</span> gt  = r + <span class="number">1</span>; <span class="comment">// arr[gt...r] &gt; tmp</span></span><br><span class="line">    <span class="keyword">int</span> i   = l + <span class="number">1</span>; <span class="comment">// arr[lt+1...i-1] == tmp</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (gt &gt; i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; tmp) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[++lt], arr[i++]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; tmp) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[--gt], arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// tmp == arr[i]</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(arr[lt], arr[l]);</span><br><span class="line"></span><br><span class="line">    _QuickSort3(arr, l, lt - <span class="number">1</span>);</span><br><span class="line">    _QuickSort3(arr, gt, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort3</span><span class="params">(T* arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    _QuickSort3(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="归并排序（MergeSort）"><a href="#归并排序（MergeSort）" class="headerlink" title="归并排序（MergeSort）"></a>归并排序（MergeSort）</h2><h3 id="Merge操作"><a href="#Merge操作" class="headerlink" title="Merge操作"></a>Merge操作</h3><p><img data-src="data:image/png;base64,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"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将arr[l, mid]和arr[mid+1, r]进行合并</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> _Merge(T* arr, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r) &#123;</span><br><span class="line"></span><br><span class="line">    T* aux = <span class="keyword">new</span> T[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        aux[i - l] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = l;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">            arr[k] = aux[j - l];</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; r) &#123;</span><br><span class="line">            arr[k] = aux[i - l];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i - l] &lt; aux[j - l]) &#123;</span><br><span class="line">            arr[k] = aux[i - l];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = aux[j - l];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] aux;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于arr[l, r]进行归并排序;l,r是闭区间</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> _MergeSort(T* arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    <span class="comment">// arr长度不大于15的时候使用插入排序</span></span><br><span class="line">    <span class="comment">// 可提升算法效率</span></span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">        <span class="built_in">InsertSort</span>(arr + l, r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (r + l) / <span class="number">2</span>;</span><br><span class="line">    _MergeSort(arr, l, mid);</span><br><span class="line">    _MergeSort(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">    _Merge1(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(T* arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    _MergeSort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP11-初始化列表</title>
    <url>/2022/01/28/CPP11-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>在CPP11之前的不同对象都有各自的初始化方式，于是初始化列表特性的目的在于统一初始化环节</p>
<span id="more"></span>

<h2 id="统一初始化"><a href="#统一初始化" class="headerlink" title="统一初始化"></a>统一初始化</h2><p>提供了基本类型、数组、自定义类型等不同对象的初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(string name, <span class="keyword">int</span> age) </span><br><span class="line">        : <span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age) &#123;</span><br><span class="line">        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">&quot;Jeson&quot;</span>, <span class="number">18</span>)</span></span>;    <span class="comment">// 传统方式</span></span><br><span class="line">Student s2&#123; <span class="string">&quot;Mark&quot;</span>, <span class="number">18</span> &#125;;   <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a1 &#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2 = &#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> * arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>]&#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure>
<p><font color=red>注意事项：自定义类型是尽量实现对应的构造函数，虽然初始化列表支持使用默认构造按照声明顺序进行初始化，但是从开发规范的角度来说，这种方式容易产生隐藏bug，不易排查</font></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student s1&#123; <span class="string">&quot;Jeson&quot;</span>, <span class="number">18</span> &#125;;    <span class="comment">// 编译通过; s1.m_name == Jeson ; s1.m_age == 18</span></span><br><span class="line">Student s2&#123; <span class="number">18</span>, <span class="string">&quot;Jeson&quot;</span> &#125;;    <span class="comment">// 编译不通过</span></span><br></pre></td></tr></table></figure>

<h2 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h2><p>初始化列表可以防止”缩窄”的隐式类型转换，对于小到大的则不做限制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a1 = <span class="number">3.14</span>;   <span class="comment">// 编译通过</span></span><br><span class="line"><span class="keyword">int</span> a2 = &#123;<span class="number">3.14</span>&#125;; <span class="comment">// 编译不过，vs2017报错（error C2397: 从“double”转换到“int”需要收缩转换）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> b1 = <span class="number">3</span>;   <span class="comment">// 编译通过</span></span><br><span class="line"><span class="keyword">double</span> b2 = &#123;<span class="number">3</span>&#125;; <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure>

<h2 id="初始化模板类-std-initializer-list"><a href="#初始化模板类-std-initializer-list" class="headerlink" title="初始化模板类-std::initializer_list"></a>初始化模板类-std::initializer_list</h2><p>cpp11提供了<code>std::initializer_list</code>模板类，可将其作为构造函数的参数，如果类有接受initializer_list作为参数的构造函数，则初始化列表语法就只能用于该构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(std::initializer_list&lt;<span class="keyword">int</span>&gt; list) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(std::initializer_list&lt;int&gt; list)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(int a, int b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a1&#123; <span class="number">1</span>, <span class="number">2</span> &#125;;    <span class="comment">// A(std::initializer_list&lt;int&gt; list)</span></span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;      <span class="comment">// A(int a, int b)</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《C++ Primer Plus（第6版）中文版》</li>
</ul>
]]></content>
      <categories>
        <category>CPP</category>
        <category>CPP11</category>
      </categories>
      <tags>
        <tag>CPP11</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP11-右值引用</title>
    <url>/2022/02/11/CPP11-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>右值引用是cpp11引入的很重要的特性，是为了支持一下两个特性而引入的：</p>
<ol>
<li>去除不必要的对象内存拷贝，<strong>极大提高了程序运行效率</strong></li>
<li>在泛型中支持完美转发（Perfect Forwarding），<strong>提升编程效率</strong></li>
</ol>
<span id="more"></span>
<p><strong>说在前面：一下所有代码均在g++编译器上进行编译并验证过的</strong></p>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>我们先来看看它和左值引用的区别</p>
<ul>
<li>左值：<code>int a = 1;</code>其中a就是左值，那种非临时的对象即有分配内存且有名字的对象就是左值</li>
<li>右值：<code>A a = A(100);</code>其中A(100)就是右值，那种临时对象且之作用于单条语句的对象就是右值。右值也可以称之为“将亡值”即即将销毁的对象<br>总的来说，一个是临时对象，一个是非临时对象。cpp11引入了这个特性为了做好左值和右值的区分。那做好区分了之后呢？有什么作用呢？这个就需要讲到<strong>移动语义</strong>了</li>
</ul>
<h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p>移动语义也叫转移语义，移动语义可以将对象内的内存资源管理权转移到另外一个对象中。移动语义和拷贝语义是相对应的，这两者的区别跟拷贝和剪切的区别一样。因此，<strong>移动语义的效率要高于拷贝语义</strong>。</p>
<p>为了方便理解，我们可以将<strong>移动拷贝构造</strong>对应<strong>浅拷贝</strong>，<strong>拷贝构造</strong>对应<strong>深拷贝</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">const</span> A&amp;) &#123; cout &lt;&lt; <span class="string">&quot;A(const A&amp;)&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// 拷贝构造</span></span><br><span class="line">        <span class="built_in">A</span>(A&amp;&amp;) &#123; cout &lt;&lt; <span class="string">&quot;A(A&amp;&amp;)&quot;</span> &lt;&lt; endl; &#125;      <span class="comment">// 移动拷贝构造</span></span><br><span class="line">        <span class="function">A <span class="title">self</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(a.self())</span></span>;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译执行，输出如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">A</span>()</span><br><span class="line"><span class="built_in">A</span>(<span class="keyword">const</span> A&amp;)</span><br><span class="line"><span class="built_in">A</span>(<span class="keyword">const</span> A&amp;)</span><br></pre></td></tr></table></figure>
<p>发现输出不符合预期，没有调用移动拷贝构造函数。是因为编译器进行了返回值优化（RVO），需要加上编译参数<code>-fno-elide-constructors</code>来关闭RVO。<strong>注意：visual studio无法关闭返回值优化，测试可使用g++编译器</strong><br>加上<code>-fno-elide-constructors</code>参数后编译执行，输出如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">A</span>()</span><br><span class="line"><span class="built_in">A</span>(<span class="keyword">const</span> A&amp;)</span><br><span class="line"><span class="built_in">A</span>(<span class="keyword">const</span> A&amp;)</span><br><span class="line"><span class="built_in">A</span>(A&amp;&amp;)</span><br></pre></td></tr></table></figure>
<p>看了上面的例子，很容易会发现一个很别扭的写法。为什么要这样<code>A a2(a.self());</code>通过调用<code>A::self</code>获取<code>a</code>对象而不直接使用<code>a</code>进行传参？这不是多此一举了？当然这是为了演示使用临时对象（将亡值）构造A对象而取了巧哈哈哈。那有什么方式可以不需要这么麻烦呢？<br>其实cpp11提供了<code>std::move</code>函数来解决这个问题！调用这个函数并没有任何移动，内部实现只是做了一个类型转化，使其可以将左值引用转化为右值引用。最终<code>a2</code>对象的构造可以改为<code>A a2(std::move(a));</code></p>
<p><code>std::move</code>的实现如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FUNCTION TEMPLATE std::move</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class _Ty&gt; _NODISCARD <span class="keyword">constexpr</span> <span class="keyword">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; <span class="title">move</span><span class="params">(_Ty&amp;&amp; _Arg)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">// forward _Arg as movable</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp;&gt;(_Arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是要注意的是<strong>执行<code>A a2(std::move(a));</code>后，对象<code>a</code>的内存就托管给<code>a2</code>，所以对象<code>a</code>成为了无效对象。 在往后的编程中要注意没有必要则不要滥用<code>std::move</code>，例如对于一些临时对象就没有必要使用<code>std::move</code>。</strong></p>
<h2 id="完美转发（Perfect-Forwarding）"><a href="#完美转发（Perfect-Forwarding）" class="headerlink" title="完美转发（Perfect Forwarding）"></a>完美转发（Perfect Forwarding）</h2><p>我们先来看看完美转发的使用场景，在讲具体场景前我们先来看看下面代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">concat</span><span class="params">(<span class="keyword">const</span> string&amp; a, <span class="keyword">const</span> string&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; (a + b).<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FUNC, <span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FUNC f, <span class="keyword">const</span> A&amp; a, <span class="keyword">const</span> B&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">invoke</span>(sum, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">invoke</span>(concat, <span class="string">&quot;Hello &quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>
<p>一切正常，完美~但是如果这时我们需要增加一个方法，那问题就来了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> &amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b = ++a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后用同样的方法进行调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">invoke</span>(increase, a, b);</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>会发现g++编译报错<code>error: binding reference of type ‘int&amp;’ to ‘const int’ discards qualifiers</code>。<strong>注：vs2017是编译通过并且结果是符合预期，还未深究是否是编译器进行了优化还是cpp17的特性。</strong></p>
<p>如果在没有<code>完美转发（Perfect Forwarding）</code>特性之前我们是如何解决这个问题的呢？很简单，针对这种情况再重载一个方法就可以了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FUNC, <span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FUNC f, <span class="keyword">const</span> A&amp; a, B&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果我们还需要支持<code>&amp;, const &amp;</code>, <code>&amp;, &amp;</code>类型的参数呢？我们来看看重载后的效果~</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FUNC, <span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FUNC f, <span class="keyword">const</span> A&amp; a, <span class="keyword">const</span> B&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FUNC, <span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FUNC f, A&amp; a, <span class="keyword">const</span> B&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FUNC, <span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FUNC f, <span class="keyword">const</span> A&amp; a, B&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FUNC, <span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FUNC f, A&amp; a, B&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相信你已经意识到问题在哪了~如果我们到支持N个参数，就需要重载<code>2^N</code>个方法，这对于开发人员来说就是噩梦！！<br>这时<code>完美转发（Perfect Forwarding）</code>就应运而生了哈哈，那我们来看看该如何改造</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FUNC, <span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FUNC f, A&amp;&amp; a, B&amp;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改造之后可以正常运行，且代码明显精简很多了哈哈，<strong>但实际上，上面改造还存在问题！！</strong></p>
<p>首先我们来回顾一个知识点，请问：<code>void invoke(FUNC f, A&amp;&amp; a, B&amp;&amp; b)</code>中的a是左值引用还是右值引用？<br>相信大部分同学会脱口而出<strong>右值引用</strong>，因为类型是<code>A&amp;&amp;</code>。很好~可惜回答错误，<strong>a是一个左值引用</strong>!</p>
<p>我在再来看看左值引用的定义：</p>
<blockquote>
<p>非临时的对象即有分配内存且有名字的对象就是左值</p>
</blockquote>
<p>因此，如果我们需要转发一个右值引用时，上面的改造显然是不够的，这时候我们就需要引入一个转发的重量级方法<code>std::forward</code><br>最终改造如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FUNC, <span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FUNC f, A&amp;&amp; a, B&amp;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(std::forward&lt;A&gt;(a), std::forward&lt;B&gt;(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看<code>std::forwark</code>的定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class _Ty&gt;</span></span><br><span class="line"><span class="function">	_NODISCARD <span class="keyword">constexpr</span> _Ty&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; _Arg)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">	</span>&#123;	<span class="comment">// forward an rvalue as an rvalue</span></span><br><span class="line">        <span class="built_in"><span class="keyword">static_assert</span></span>(!is_lvalue_reference_v&lt;_Ty&gt;, <span class="string">&quot;bad forward call&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::forward</code>也只是做了类型转换，为什么<code>A&amp;&amp;</code>可以实现完美转发呢？这里面就涉及到两个概念<code>万能引用</code>和<code>引用折叠</code></p>
<h3 id="万能引用"><a href="#万能引用" class="headerlink" title="万能引用"></a>万能引用</h3><p><code>T&amp;&amp;</code>就是一个万能引用，即可以接受任何类型的参数，<code>T</code>为模板类型T。我们都知道<code>T</code>是一个类型占位符，因此<code>T</code>可以是<code>&amp;&amp;</code>、<code>&amp;</code>、<code>const &amp;</code>等。进而可以知道会推导成<code>T&amp;&amp; &amp;&amp;</code>、<code>T&amp; &amp;&amp;</code>、<code>const T&amp; &amp;&amp;</code>。我们都知道cpp编译器是不允许构建引用的引用这个类型的，那这些<code>T&amp;&amp; &amp;&amp;</code>、<code>T&amp; &amp;&amp;</code>、<code>const T&amp; &amp;&amp;</code>是什么呢？这就是我们下面要介绍的<strong>引用折叠</strong>的内容</p>
<h3 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h3><p>这些“引用的引用”就是cpp11编译器在推导<code>万能引用</code>的具体类型时的中间状态，具体推导规则如下</p>
<table>
<thead>
<tr>
<th>中间状态</th>
<th>推导类型</th>
</tr>
</thead>
<tbody><tr>
<td>T&amp; &amp;&amp;</td>
<td>T&amp;</td>
</tr>
<tr>
<td>T&amp;&amp; &amp;</td>
<td>T&amp;</td>
</tr>
<tr>
<td>T&amp; &amp;</td>
<td>T&amp;</td>
</tr>
<tr>
<td>T&amp;&amp; &amp;&amp;</td>
<td>T&amp;&amp;</td>
</tr>
</tbody></table>
<p>有了以上的推导规则构成完美转发的基础</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://oopscenities.net/2014/02/01/c11-perfect-forwarding/">C++11: Perfect forwarding | De C++ et alias OOPscenitates</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/161039484">聊聊C++中的完美转发 - 知乎</a></li>
</ul>
]]></content>
      <categories>
        <category>CPP</category>
        <category>CPP11</category>
      </categories>
      <tags>
        <tag>CPP11</tag>
      </tags>
  </entry>
</search>
